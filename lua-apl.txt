<style type="text/css">
  code{white-space: pre; background-color: #F1F1F1;}
</style>

Lua⋆APL User's Manual
=====================

© Dirk Laurie 2013  Lua-style MIT licence

Read what it says in the README about installation and UTF-8.

APL is a functional language with extensive array processing abilities,
originally designed by Ken Iverson in the 1960's. Lua⋆APL is an extension
of Lua that gives access to the power of APL (the APL asterisk `⋆` means
`Power`) without leaving the comfort and security of Lua.

There are three modes of usage, which can be thought of as analogous to
the C API, scripting language, and standalone executable of Lua.

Library mode: 
~   APL functionality is offered as a Lua library, which
    makes no use of the APL character set except in its help 
    information. You type in Lua commands like:

        Reshape(Take(1,Add(1,n)),Attach2(n,n))

Lua mode: 
~   Functions callable from Lua can be written in APL. This is
    achieved via a function `apl` rather like Lua's `load`, which 
    generates intermediate Lua code consisting of chained calls to the APL
    library. You type in Lua commands like:

        apl"(n,n)⍴(n+1)↑1"()

    The `apl` function invokes an APL compiler to translate this to 
    the string of calls shown above.

APL mode: 
~   Bare APL code can be entered directly at the terminal. You type 
    in a mixture of Lua and APL commands like:

        n=10
        (n,n)⍴(n+1)↑1

    The APL interpreter decides the second line must be APL code and 
    modifies it to the Lua mode code shown above. If it seems to be Lua 
    code, the interpreter does not do the translation.

    This works because APL code has such a distinctive appearance. Even 
    a primitive guessing algorithm can identify APL code with a high 
    rate of accuracy. Code deemed to be APL is translated to load and
    execute as in Lua mode, but the result is printed by default as 
    typical APL systems do. The effect is to give an APL-like 
    look-and-feel. If you already know APL, jump straight to the 
    section on [APL mode] and try it out.

The code examples shown here, even the ones in the section on Lua mode,
use the three-space prompt of the Lua⋆APL standalone rather than the
conventional Lua prompt, but all code except that shown in the section
on [APL mode] works on a vanilla Lua interpreter too.

In this document, we do not consistently use "APL" and "Lua⋆APL" as
denoting different things. "APL" is a fairly vague term, meaning more or
less "a typical APL implementation" or even "the APL way of thinking",
whereas "Lua⋆APL" is a specific term for this implementation, which of
course also falls under the shadowy APL umbrella.

Words like "standard" refer to features that are typically found in
almost every APL dialect since about 1980, well summarized in the
[Wikipedia article](http://en.wikipedia.org/wiki/APL_syntax_and_symbols).
"Non-standard" in the case of Lua⋆APL means that I am using an unusual
APL symbol without making any attempt even to find out how modern APL
implementations use it (the latest APL that I take into account is APL2,
and even in that case compatibility across the board is not aimed at). 
Please contact me if you feel that some other symbol for the same concept, 
or some other concept for the same symbol, is actually semi-standard by now.

If you would like to know much more about APL than you currently do,
there are several well-organized websites of modern commercial APLs,
e.g. <http://www.microapl.com/apl_help>. 

When I wrote this line, the version number displayed by the start-up 
message was `0.4.0`. As long as the first number is `0`, anything might 
still change.

Library mode
============

In this mode, APL is a distant inspiration only, but since the other
modes make use of it, it is documented quite extensively here.

Actually, I do not expect anybody to stop at library mode, but it
is the easiest place to start for Lua programmers who do not know any
APL; eventually one needs know about it, if only because some library
functions have optional extra parameters that are fixed at default 
values when called from APL. It is best learnt in an interactive session 
because an extensive amount of interactive help is available.

I'm assuming you loaded the module by 

       apl=require'apl'
       apl:import'*'

That call to `apl:import` adds the 90-plus items of the module to the
global environment. Almost all of them are quite distinctively named,
but if you instinctively recoil in horror, muttering "pollution" under
your breath, by all means omit that line and prepare to type numerous
instances of `apl.`, or (in a script) replace it by assigning the ones
you actually use to local variables. Better, actually: just hold your
horses till you get to Lua mode; no large-scale imports necessary there.
 
A thorough knowledge of what the library offers is not needed if you
already know APL and plan to use mostly APL mode. If you already know
APL, by all means skip straight to [APL mode] and only read this part
later. If you don't want to build the APL interpreter, skip to [Lua
mode]. 

The module `apl` loads a C module `apl_core`, documented in the 
Programmer's Guide. 

The module returns a table with keys named by the following convention:

-  `CamelCase`: APL functions (mostly mapped to APL symbols later)
-  `lowercase`: Lua functions (not usually called from APL code)
-  `_CAPS`:     needed by the system or providing information
-  `_lowercase`: control variables

"APL functions" of course does not imply that they are anything else
than just Lua functions. It merely means that these are mostly the 
functions that lie at the heart of APL, closely following the original 
design of Iverson. There is a simple mapping between Lua postfix 
notation and APL infix notation, for example:

   Lua                   APL
 ------------------- -- -----------------
      `_w`                 `⍵`
      `_a`                 `⍺`
   `func(_w,_a)`        `⍺ func ⍵`
   `Range(_w)`            `⍳⍵`
   `Find(_w,_⍺)`          `⍺⍳⍵`
   `Shape(_w)`            `⍴⍵`
   `Reshape(_w,_a)`       `⍺⍴⍵`
   `Decode(_w,_a)`        `⍺⊤⍵`
   `Add(_w,_a)`           `⍺+⍵`
   `Sub(_w,_a)`           `⍺-⍵`
   `Mul(_w,_a)`           `⍺×⍵`
   `Div(_w,_a)`           `⍺÷⍵`
 ------------------- -- -----------------

In total, over 90 of these functions are provided in library mode. The 
APL symbols used for them, even those which in Lua denote arithmetic 
operators, must be thought of as names, not as as special characters,
even though those names are not used in library mode. 

One and the same APL name often does duty for two Lua names. This is
possible because APL infix syntax allows the compiler to distinguish
between monadic and dyadic functions (see [Valence]) and select the
appropriate function. That distinction is possible in Lua too, but only
at run time, when one can test whether the second argument of a function
is present and not nil.

APL syntax makes the distinction already at compile time, so that
overloading of the Lua names of the functions is not necessary. Instead,
the names have been chosen to be descriptive of what the functions do.

Certain semi-standard descriptive names are often used in APL
documentation, such as
<http://en.wikipedia.org/wiki/APL_syntax_and_symbols>. These have been
retained in some cases (`Ravel`, `Reshape` etc), abbreviated in others
(`Exp` rather than `Exponential` etc), and occasionally replaced by
totally different names (`Pow` rather than `Exponentiation`). Functions
corresponding to Lua arithmetic metamethods have been given basically
the same name (`Unm` for unary minus, etc.) but there's no rule, really;
I've done what feels programmer-friendly to me.
  
The documentation, in particular the interactive help, freely uses both
the Lua names and APL symbols simultaneously, so you will acquire a
smattering of APL more or less painlessly even while using library mode
only.

APL types and Lua types
-----------------------
 
An APL-like type classification consisting of functions, operators, 
scalars, vectors and matrices is implemented via Lua values. 

The APL terms "function" and "operator" are used in a different sense 
than in Lua. The symbols for arithmetic, comparison etc are called 
"operators" in Lua and the parser treats them by strict precedence rules. 
In APL, those symbols are names of functions (many of them are actually
three-byte names that only look like a single character thanks to UTF-8), 
there is no notion of precedence, and "operator" means a function that 
acts on functions.

-   APL functions are Lua functions of one or two variables, returning 
    one value. In the documentation, the names `⍺,⍵` and `_a,_w` 
    are used respectively when the function is called from APL or from
    Lua.  The _left_ argument `⍺` in APL infix notation becomes the 
    _second_ argument `_a` in Lua postfix notation. In APL, the parser
    can see whether `⍺` is omitted; in Lua, providing `_a` as nil is 
    equivalent to omitting it.

-   APL operators are also Lua functions of two variables, but:

    1.  Their arguments and return value are functions.
    
    2.  In the documentation, the first argument is called `f` and 
        the second `g` in the documentation of both APL and Lua.

    3.  The _left_ argument `f` in APL infix notation becomes the 
        _first_ argument `f` in Lua postfix notation and must always
        be present; the (right) second argument `g` is usually absent, 
        `Inner` being the only function in `apl-lib` that uses it.
     
    4. Operators have a higher priority than functions.

-   APL scalars are Lua numbers and strings. Other Lua types are treated
    as scalar. In particular, a Lua function can be an APL scalar. 
    APL needs to be told at the lexical level (via `register`) which
    names will be used to denote functions.

-   APL arrays (vectors and matrices both) are Lua index-1 tables. The 
    ordering of matrix elements is row-wise. Lua⋆APL arrays do not have
    a type as in classic APL: each element is a Lua value and carries
    its own type. In particular, an empty array has no type.

APL arrays share a common metatable, which provides `__tostring`,
`__index` `__newindex` and `__lt` (the last of these does a
lexicographic comparison). Numeric keys in the simplest case obey the
same conventions as the Lua table library: the positive integer keys of
`A` are expected to form a solid block from 1 to `#A`. The full truth is
more complicated; see [Array operations] and [Indexing].

String keys are used to achieve the extra functionality of APL arrays:

`A.apl_len`
:   Optional field. If present, this is the value returned by the Lua 
    `#` operator.
`A.rows, A.cols`
:   Number of rows and columns (matrix only).

It is possible to synthesize an APL array in vanilla Lua. However, it is
not recommended, and never necessary, for two reasons:

-   In almost all cases, the APL library will accept a Lua table as 
    a substitute for an APL vector.
-   All tables returned by the library are APL arrays. In particular,
    the function `Copy` will convert a Lua array to an APL array.

For example, to define a matrix (see [Formatting] for `_format`)
one calls `Reshape` with a Lua table and the desired shape as
arguments; to convert it to an APL vector one calls `Ravel`.

       apl._format = 'raw'     
       A = Reshape({11,12,13,21,22,23},{2,3})   
       print(A)
    [11,12,13;21,22,23]
       print(Ravel(A))
    (11,12,13,21,22,23) 

The _rank_ of an array is the number of indices it takes to reference
an element from it. APL allows rank 0 (scalar), rank 1 (vector) and 
rank 2 (matrix). APL does not distinguish between row vectors and column
vectors; if you need to do that, use a one-row or one-column matrix.

`Shape` is the APL analogue of Lua's `type`, defined as follows:

-   number: `Shape(a) = {}`
-   vector: `Shape(x) = {#x}`
-   matrix: `Shape(A) = {A.rows,A.cols}`
-   string: `Shape(s) = #s`
-   other scalar: `Shape(other) = nil` 

It should be stressed that APL matrices are not tables of tables, 
they are simple tables that carry shape information.

Lua userdata values are also APL scalars. If equipped with the right 
metamethods, they might work inside APL expressions, but this 
possibility is unexplored.

Formatting
----------

APL normally uses a pretty-printing output format.

       print(Reshape({11,12,13,21,22,23},{2,3}))
    11 12 13
    21 22 23
       
This is produced by the `Format` function.

While nice-looking, this format makes it hard to notice the subtle
distinctions that we will need to make in this manual, and therefore
we have in many of the examples used raw format. The Lua⋆APL `Format`
function in general takes two arguments.  The second argument `"raw"` 
selects one-line output with the following conventions:

- undelimited: scalars
- delimited by braces: {Lua,table}
- delimited by parentheses: (APL,vector)
- delimited by brackets: [APL,matrix;semicolons,separate,rows]

If the second argument is absent, the `_format` field in the module 
table is interrogated. Since the module table is not read-only, the user
can assign something (e.g. `"raw"`) to `apl._format`, 

Not-a-number is printed as `NaN` and nil as an underscore.

       print(Format{1,nil,0/0,"abc"})
    {1,_,NaN,'abc'}

The `Format` function works recursively until the result is a string.

Array operations
----------------

The whole point of using APL is so that one never (well, hardly ever)
needs to use an explicit table index. The vast majority of its functions
accept array arguments and return array values.

The APL library handles nils in a table gracefully in the case of all
scalar functions (i.e. functions that apply term-by-term to array
arguments).

       x=Copy{1,2,nil,4}; y=Reverse(x)
       print(Add(x,y))
    {5,_,_,5}

The actual storage of a very sparse vector will be compact, using mostly
the hash part of a Lua table, but there is no true optimized support for 
sparse vectors. The functions simply iterate over the known length of 
the array and skip nils.

###Indexing

APL arrays have a fixed size, which is frozen for a given Lua table
`tbl` by setting its metatable to the APL array metatable. Or rather,
it is the set of indices with non-nil values that is frozen. The 
`__index` and `__newindex` metamethods come into play whenever an 
attempt is made to access any index except those which are actually 
in use. Conversely those metamethods are _not_ invoked in the case of 
a valid index. 

- A nonexistent numeric or string index is illegal.
- If you assign nil to a numeric or string index, that index 
  becomes unavailable permanently, no matter what `apl_len` is,
  except via `rawget` and `rawset`.
- A legal numeric index to a matrix indexes it as a vector, in row-major
  order (i.e. matrices are stored row by row).
- A table-valued index to a vector should either be an APL vector (Lua
  array acceptable) or an APL matrix (Lua array with `rows` and `cols`
  set acceptable). The result will have the same shape as the index.
- A table-valued index to a matrix should be a pair of items, each of
  which may be a number or a Lua array (APL vectors and matrices are 
  acceptable, but lose their magic powers) which select the rows and 
  columns. The result will have rank determined by the index types, and
  shape determined by the lengths of the lists.
- A function-valued index should be an iterator that returns a valid 
  numeric index until it returns nil. The array being indexed is 
  treated as a vector, and the result is always a vector.

The two metamethods are available in the library as `Get` and `Set`,
and can be invoked explicitly, even with ordinary non-APL tables.
You should only do that with a function-valued or table-valued
index, because you are bypassing the Lua indexing mechanism. Other 
indices are passed to routines normally called only for nonexistent 
indices; the routines know that a scalar index that gets this far
must be invalid, and throw an error.

       x={1,2,3,"A","B","C"}
       y={10,20,30,A='a',B='b',C='c'}
       print(Get(x,{5,2,4}))
    ('B',2,'A')
       Set(y,Get(x,{5,2,4}),{100,200,300})
       print(y)
    table: 0x93e4e90
       print(Copy(y),y.A,y.B)
    (10,200,30)	    300     100
       Get(y,1)  -- index not a function or a table: trouble!
    ./apl-lib.lua:520: bad argument #2 to 'core_index' (index out of range)

### Nested arrays

The elements of an APL array may be themselves be arrays, since the 
inner structure of an element is opaque to APL, i.e. APL thinks of 
anything stored in an array as scalar. 

       A={{1,2},{3,4},{5,6}}; print(Format(A))
    {{1,2},{3,4},{5,6}}
       B=Copy(A); print(B)         
    ({1,2},{3,4},{5,6})            
       print(A[1]==B[1])
    true

That `true` says that `A[1]` and `B[1]` are actually one and the same 
table: the elements are still the original Lua tables. This is not quite
what is usually wanted from a routine called `Copy`. The operator `Each` 
applies a function term-by-term to every element of a table and returns 
a new array with the same shape as the original.

       C=Each(Copy)(A); print(C)
    ((1,2),(3,4),(5,6))
       print(A[1]==C[1])
    false

The elements are now newly minted APL arrays, as is the containing
array.

`Each` works equally well for monadic and for dyadic functions. The
APL compiler can tell the difference.

       print(Each(Reshape)({{1,2,3,4},{5,6,7,8}},{{2,2}}))
    ([1,2;3,4],[5,6;7,8])

In this example, the two arguments are both nested arrays, so they
look to APL like a two-element and a one-element array. A dyadic
function created by `Each` expects two arrays of compatible shape for 
term-by-term operations, but will accept a one-element argument
to act as a constant value. You can override that permission by 
supplying extra parameters to `Each` (this feature is only available
when calling `Each` from Lua; the APL operator `¨` does not allow
the possibility.).

       print(Each(Add)({{1,2,3,4},{5,6,7,8}},{1}))
    (2,3,4,5) (6,7,8,9)
       help(Each)
    Each(f): f¨ → make a term-by-term function from f
    Each(f,x_w,x_a): (no APL equivalent) Fine-tune constant arguments.
       x_w=x_a=0: the shapes of _w and _a must be compatible.
       x_w=1, x_a=1: _w,_a may be a singleton, which will be used every time.
       x_w=2, x_a=2: _w,_a is used as such every time even if it is a table.
       print(Each(Add,1,0)({{1,2,3,4},{5,6,7,8}},{1}))
    ./apl-lib.lua:497: bad argument #3 to 'both' (shapes are incompatible)

A vector of vectors of the same length can be combined into a matrix,
and a matrix can be converted to a nested array. These operations are
so commonly needed that the APL2 notations `⊂` (Enclose) and `⊃` (Disclose)
have been borrowed (but not with the exact same meaning), and the 
non-standard APL function `Rerank` has have been invented as an
umbrella for them in library mode.

       help"⊂"
    Enclose: ⊂⍵ makes an array of rows from a matrix or concatenates a vector.
    Depends on _join.
       help"⊃"
    Disclose: ⊃⍵ makes a matrix from an array of rows, or a string vector from
    a string. If ⍵ is a matrix, each ⍵[i] is treated as a vector and padded to 
    the maximum length using zeros or empty strings. If ⍵ is a string, ⍵ is
    split into substrings, depending on _split.
       help(Rerank)
    Rerank: Rerank(_w,_a): array of one rank higher (_a>0) or lower (_a<0),
       stacking rows (±1) or columns (±2). See Disclose/Enclose.

The behaviour of `Enclose` and `Disclose` on strings is discussed under
[Strings].

### Axis-dependent functions and operators

Several APL vector functions generalize to matrices by operating either
on the rows or on the columns. In APL notation, the distinction is
made by using different symbols (`⊖ ⌿ ⍀ ⍪` are the row-wise counterparts
to `⌽ / \ ,`). There are typically three different functions at issue here.

       help(Attach)
    Attach(⍵,⍺): ⍺,⍵ → elements of ⍺ followed by elements of ⍵
       help(Attach1)
    Attach1(⍵,⍺): ⍺⍪⍵ → rows of ⍺ followed by rows of ⍵
       help(Attach2)
    Attach2(⍵,⍺): ⍺,⍵ → columns of ⍺ followed by columns of ⍵
       print(Attach({1,2},{3}))
    (3,1,2)
       print(Attach1({1,2},{3}))
    [3,0;1,2]
       print(Attach2({1,2},{3}))
    [3,1,2]

As you can see, `Attach1` pads short rows to the length of the longest list.
`Attach2` pads short columns, but vectors count as one-row matrices.

In Lua⋆APL, the principle is "act on rows when the axis is 1, act 
on colums when the axis is 2", and the implementation is to convert 
the matrix to a nested array, do something to that nested array, 
and convert back.

In the case of `Rotate`, there is a possibility of confusion here.
`Rotate1(A,1)` must rotate the rows of `A` up by 1, no question.
What does `Rotate1(A,{2,1,3,4})` do, rotate each row of `A` 
individually by the specified amount? If so, `Rotate1(A,{1,1,1,1})` 
would rotate every row left by 1, i.e. it would rotate the columns
left by 1. That would violate the APL principle that a singleton
does the same as a constant vector. So we must violate the Lua⋆APL
principle for the sake of the greater cause: `Rotate1(A,{2,1,3,4})`
rotates each _column_ of `A` individually by the specified amount.

       A=Copy{1,2,3,4;5,6,7,8;9,10,11,12;rows=3,cols=4}; print(A)
     1  2  3  4
     5  6  7  8
     9 10 11 12
       print(Rotate1(A,{2,1,3,4}))
     9  6  3  8
     1 10  7 12
     5  2 11  4
       
### High-level matrix functions

In the case where `A` is a non-singular square matrix, `MatDiv(A,b)` 
returns the unique solution of a system of linear equations and 
`MatInv(A)` to the matrix inverse.

For a singular or non-square matrix, the numerical rank is determined. 
`MatDiv(A,b)` returns the minimum-norm least-squares solution, and
`MatInv(A)` the pseudo-inverse, for that rank.

The determination of rank depends on non-negative numbers known as
the singular values of `A` (see any text on matrix computations) and
on the comparison tolerances (see [Global control variables]). 
Specifically, if `_act` is nonzero, singular values less than `_act` 
count as zero; if `_rct` is nonzero, singular values less than 
`_rct*s[1]` count as zero. The rank equals the number of nonzero
singular values. 

In library mode, the function `SVD` has been provided for the 
convenience of those who know the theory. Its return value is a Lua 
table containing a vector `S` of singular values and nested arrays 
`U` and `V` of left and right singular vectors respectively. At this 
point library mode becomes just too inconvenient, so we resort to
Lua mode.

       A=Reshape(Range(12),{3,4}); print(A)
     1  2  3  4
     5  6  7  8
     9 10 11 12
       U=USV.U; V=USV.V; S=USV.S; print(S)
    25.43684 1.722612 2.681529e¯16
       B=apl"+/S×¨U(∘.×)¨V"(); print(B)
     1  2  3  4
     5  6  7  8
     9 10 11 12
       
Strings
-------

Lua⋆APL does not have character arrays, any more than Lua itself has
them. A string is a scalar. If you need to operate on individual bytes
of a string, the Lua function `string.byte` combines well with the 
library.

       tobytes = function(s) return {s:byte(1,-1)} end
       frombytes = function(s) return string.char(unpack(s)) end
       M=Each(tobytes){"The","quick","brown","fox"}; print(M)
    ({84,104,101},{113,117,105,99,107},{98,114,111,119,110},{102,111,120})
       print(Each(frombytes)(M))
    ('The','quick','brown','fox')

Lua⋆APL does have string arrays, and support for them is provided by the 
functions `Disclose` and `Enclose`. These functions normally act 
respectively on nested arrays and matrices, but `Disclose(str)` splits 
a string into UTF-8 codepoints and `Enclose(vec)` concatenates a vector.
More precisely, `Disclose` returns the result of `apl.util.utfchar`
and `Enclose` the result of `table.concat`.

This support can be customized: see [Splitting and joining].


Global control variables
------------------------

APL traditionally makes use of some control variables that affect its
overall behaviour. Which these are, differs from one APL implementation
to the next, so they are sometimes called "system variables". In Lua⋆APL,
their names start with an underscore, and they are stored in the module
table.  

  --------------- -- -------------------------------------------------
  `_act`             Absolute comparison tolerance.
  `_rct`             Relative comparision tolerance.
  `_format`          Default format for monadic `Format`.
  `_split`           String splitting function.
  `_join`            Table concatenation function.
  --------------- -- --------------------------------------------------

###Comparison tolerance

Lua⋆APL does a straightforward comparison only in the case of functions
that don't test for equality (`TestNE`, `TestGT`, `TestLT`). Functions
that give 1 in the equality case (`TestEq`, `TestGE`, `TestLE`) actually
test for approximate equality. Either of `abs(_a-_w)<apl._act` or
`abs(_a-_w)<apl._rct*abs(_w)` also counts as equality if the
corresponding control variable is defined,

The philosophical implications are mind-blowing (`TestEq(x,y)` may not
give the same result as `TestEq(y,x)`, etc) but the practical effect is
that with the default settings, the equality tests do what most sane
people (that excludes numerical analysts, of course) expect them to. If
you don't want them, you can always set those tolerances to zero or nil,
or just do the complementary test (`1-TestNE(x,y)` etc).

       s=1/7; t=s+s+s+s+s+s+s; print(1==t)
    false
       print(TestGE(1,t))
    1
       apl._act=0; apl._rct=0
       print(TestGE(1,t))
    0

###Splitting and joining

The routines called by `Disclose` and `Enclose` for splitting and joining
by default are `apl.util.utfchar` and `table.concat` respectively. You can
change that by setting your own monadic functions in the global control
variables `apl._split` and `apl._join`; to revert to default, set them to 
`nil`.

`_split` is only called when `Disclose` receives a string; `_join` is
called for any table that is not a matrix, and the usual Lua coercion
of numbesr to strings will be applied.

List of Lua⋆APL functions
-------------------------

The current version may give a slightly different result, so do the following
yourself. For most of these, you can get interactive help.

       help(apl)
    Contents: Abs Add And Assign Attach Attach1 Attach2 Binom Ceil Circ
        Compress Compress1 Compress2 Copy Deal Decode Define Disclose Div Down
        Drop Each Enclose Encode Execute Exp Expand Expand1 Expand2 Fact Find
        Floor Format Get Has Inner Length Ln Log MatDiv MatInv Max Min Mod Mul
        Nand Nor Not Or Outer Output Pass Pi Pow Range Ravel Recip Reduce
        Reduce1 Reduce2 Rerank Reshape Reverse Reverse1 Reverse2 Roll Rotate
        Rotate1 Rotate2 SVD Same Scan Scan1 Scan2 Set Shape Sign Sub Take TestEq
        TestGE TestGT TestLE TestLT TestNE ToString Transpose Unm Up _act _rct
        help import lua register util  
       help(Transpose)
    Transpose: ⍉⍵ → matrix transpose of ⍵

`apl.util` contains utility functions. They are lightly documented by
`help`, even if the help is merely the Lua code.

       help(apl.util)
    Contents: argcheck arr both checksize checktype compat each filler get
        invert iota is is_int is_not replace rho set shape start sum utfchar
        utflen

Lua mode
========

I'm assuming you loaded the module by 

       apl=require"apl"
       apl:import()

That call to `apl:import` adds `help` and `lua` to the global 
environment.

This is the mode in which to write programs, but makes quite a
convenient interactive session too. If you prefer the control and safety
of a family car to the breathless excitement of an open-top sports
model, you will be happier with Lua mode than APL mode.

The compiler works as follows:

1.  APL source is split into independent chunks by the `⋄` (diamond)
    separator, each of which is compiled on its own. This implies that
    you are not allowed to use the diamond inside an APL string. You are
    also not allowed to use the single-quote inside. If you really need
    those two characters inside a string, create it using Lua and refer
    to it inside APL by its global name.

2.  An APL chunk is lexed, parsed and translated to Lua code in one step
    by a single LPeg grammar. I thank Roberto Ierusalimschy from the
    bottom of my heart for this absolutely ideal tool.

3.  The result of the previous step is a chunk of Lua code, which looks
    almost exactly like what you would code in library mode, and a number
    identifying the position in the APL code at which the compiler could
    not continue. If that is before the end of the string, the
    compilation failed, and the APL code is displayed with an arrow
    pointing to that position and an error message. This is maybe only
    slightly more helpful than saying there is an error somewhere, but
    at least it gives a starting point.

           ⍺∘.×(⍺←⍳5)
        ./apl-compiler.lua:116: APL syntax error
        ⍺∘.×(⍺←⍳5)
         ↑

    There is nothing wrong with the outer product to which the arrow
    points. The real error is that assignment to local variables is only
    allowed at the start of a statement, but the compiler makes no clever
    second-guessing of common mistakes. All that the arrow says is that
    `⍺` by itself would have been legal APL code, but no substring that
    goes beyond the arrow is legal. 
    
4.  If the compilation of all the APL chunks succeeded, the Lua chunks
    produced by the compiler are concatenated; if there was only one
    chunk, `return` is put in front of it; the result is tacked onto a
    standard preamble and the whole lot is processed by `load`, with the
    APL runtime environment as fourth argument.

5.  If `load` succeeds (which it should, otherwise there is a compiler
    bug that should be reported), the original APL code is set as the
    help string for the Lua function, which is returned. The Lua code
    can be recovered by `apl.lua`.

All this is done by calling `apl` (it is a table, yes, but a callable
table), which returns an anonymous function that can be stored or 
executed.

       sorted_down=apl"⍵[⍒⍵]"
       print(lua(sorted_down))
    return _w[Down(_w)]
       x=apl"10?100"()
       print(x)
    (49,23,96,93,19,89,67,48,66,35)
       print(sorted_down(x))
    (96,93,89,67,66,49,48,35,23,19)

The APL runtime environment has mostly the same keys and values as 
`apl`, but it is a different table. You have read-write access to the 
module table; you have no access to the APL runtime environment. There 
are certain advantages to this.

       print(apl.Deal(100,10))
    (85,41,79,81,92,24,38,3,34,60)
       apl.Deal = function() print"Your APL system is now stoned" end
       print(apl.Deal(100,10))
    Your APL system is now stoned
       print(Execute"10?100")
    (49,23,96,93,19,89,67,48,66,35)

I'm not saying that a sufficiently sneaky hacker can't access it — 
after all, this is open-source code — merely that you can't easily 
clobber it by accident.

It is possible to write quite long stretches of APL this way, but it
is even harder to find a computing task that genuinely requires a 
long stretch of APL code. What one does need fairly often is a way
to separate expressions that belong to the same chunk. The reason is
that assigment to the local variables  `⍺` and `⍵` is only allowed 
at the beginning of a statement.

The statement separator `⋄` is used for thus purpose. Also available 
is the APL comment symbol `⍝`, which makes everything up to and 
including the next linebreak invisible to the compiler.

       sievestep=apl[[
          ⍺←⍺×⍳⌊(⍴⍵)÷⍺    ⋄  ⍝ multiples of ⍺ not past end of ⍵
          ⍵[⍺]←0          ⋄                 ⍝ assign 0 to those
          ←⍵      ⍝ explicit return required in multi-statement 
       ]]
       print(lua(sievestep))
    _a=Mul(Range(Floor(Div(_a,Shape(_w)))),_a); _w[_a]=0; return _w 
 
You can see from the Lua listing why there is a restriction on where you
can assign to a local variable: it gets its own separate Lua statement.
On the other hand, assignment into a table, such as the APL or Lua
global environment, is implemented as a function call, which can appear
anywhere.
    
However, program logic has not been implemented in APL. You will need
mixed-language programming, using Lua for the logic. If the original 
environment that was active when the library was loaded is still in
effect, APL code can see global the Lua variables: see [Namespaces].
However, locals and upvalues are invisible, so the process needs some 
care when used from inside a function. 

The canonical APL way is to do everything via named or anonymous 
functions. Your data is passed in as arguments `⍵` and `⍺`, values
are returned. If you pass a table, that table itself is mutable.

       function primes(n)
       local x=apl"⍳⍵"(n)
       local step=apl"⍵[1↓⍺×⍳⌊(⍴⍵)÷⍺]←0 ⋄ ←⍵"
       for i=2,math.sqrt(n) do 
          local p=x[i]
          if p and p>0 then step(x,p) end 
       end
       x[1]=0
       return apl"(⍵>0)/⍵"(x)
       end
       print(primes(100))
    2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97

Valence
-------

In Lua, the number of arguments to a function is no big deal. You
supply more arguments than the function was defined with? The others
are ignored. You supply fewer arguments than the function was defined 
with? The missing ones are given the value `nil`. This behaviour lies 
at the very heart of the Lua way of thinking,

In APL, the number of arguments to a function is absolutely central.
Funtions are _niladic_ (no arguments), _monadic_ (one argument) or
_dyadic_ (two arguments). At present, niladic functions can only be 
executed from Lua; Lua⋆APL syntax does not make provision for them. 
Functions may be _ambivalent_, i.e. take either one or two arguments, 
deducible from the way the expression is formed, and in such a case 
may call different Lua functions.

The APL syntax allows the valence of a function to be determined from
its context in the expression. Just like Lua knows the difference 
between unary minus and subtraction, APL knows the difference between
monadic and dyadic use of a function symbol — in fact, about 20 APL
symbols can be used for either a monadic or a dyadic function, and
in almost all cases, those functions are implemented by different 
Lua functions.

Operators are even more complicated. In principle there are numerous
possibilities for the valence of an operator, its arguments and its
result. The original APL operators solve the difficulty by taking only
the valence of the operator into account, in effect treating the 
arguments and result as ambivalent.

Monadic operators
:   A monadic operator acts on a function (which is the left argument
    of the operator) to form another function.

Dyadic operators
:   A dyadic operator acts on a pair of functions to form a single
    function. 

Other implementations are not always as catholic as the above suggests;
some APLs do not allow operators to act on user-defined functions.

Lua*APL, on the other hand, is very permissive. A monadic operator is 
simply one that acts on one function, a dyadic operator is one that 
acts on two functions. The resulting function could be either case be
monadic or dyadic; we'll know when it is used. In cases where the same 
name could denote either a monadic or a dyadic function, the dyadic 
function takes precedence.

Lua⋆APL goes even further: it accepts functions created by operators 
as arguments to another operator. In such cases, parentheses must be 
used. 

It is occasionally useful to have a dummy left argument to a dyadic 
operator. The jot `∘` is traditionally used for that purpose. It is
treated as a function `Pass` by Lua⋆APL. `Pass` is ambivalent and
returns nothing. It can be used to suppress output.

       a←1+!10
    3628801
       ∘a←1+!10  -- nothing is printed

Namespaces
----------

Functions compiled by the APL have `_ENV` set to the to the APL runtime
environment. This environment is not visible to the Lua user.

You have three main mechanisms for getting values back from compiled
APL code.

-  Return values of APL statements. 
-  Global assignment.
-  Printing to the console (see [Functions added at compiler level]).

Three namespaces are visible from an APL function.

-   The local namespace of a function. This contains only the names `_a`
    and `_w`, which start out as the values of the left and right 
    arguments, but can be assigned to. They are referred to in the APL
    code as `⍺` and `⍵` respectively.

-   The APL global namespace. This contains the functions currently
    known to APL under their Lua names. The underscore, though 
    alphabetic in Lua, has a special meaning during APL assigment 
    and is therefore best avoided. The APL namespace is a field `_V` 
    in the APL runtime environment.  

-   The Lua global namespace, which is set as the `__index` field of the
    metatable of `_V`. The APL global namespace takes precedence when
    retrieving a value, but if it does not contain that name, the Lua
    namespace is tried next. Assignment into the Lua namespace from APL
    is achieved by putting an underscore in front of the name. That
    underscore is not part of the real name; it merely indicates which
    namesapce to use.

Several other namespaces are used internally by the APL compiler. These 
are collectively referred to as the APL registry, and contain the same
functions as the APL runtime environment, but keyed by their APL names.

The APL compiler assumes that a name refers to a variable unless it
has been added to the APL registry. The easiest way is to assign a
newly defined function to an APL name. The newly defined function will 
be defined as an ambivalent function (use Lua's runtime distinction if 
necessary) and can be used wherever a built-in APL function can. 

       run=function(str) print(apl(str)()) end
       cf=function(_w,_a) return _w+1/_a end
       run"2 cf 3"
    ./apl-compiler.lua:113: APL syntax error
    2 cf 3
      ↑
       run"cf←cf"    
    cf
       run"2 cf 3"
    3.5
       run"cf/⌽2 1 2 1 1 4 1 1 6 1 1 8"
    2.718281835206

For direct assignment to work, the name must be a valid Lua name too.

More flexibility is offered by the `apl.register` function. You can
define new operators, use a different APL name (which need not be
a valid Lua name) from the Lua name), and define help. 
See `help(apl.register)`.

Some functions that interact with the compiler
----------------------------------------------

Note that `←` and `∇` are used in a non-standard way.

`←` (`Assign`)
~   Returns its right argument after assigning it to the left argument.
    This can be used inside expressions, except when the left argument
    is a parameter (`⍺` or `⍵`). In that case, it must occur at the
    very start of the expression.  When used monadically (also only 
    allowed at the start of an expression), `←` forces a `return`
    instruction to be generated. 

    If the right argument is a Lua function, `Assign` registers it for
    use as a function in APL expressions under the name specified by the
    left argument.

`∇` (`Define`)
~   This is the only Lua⋆APL function that 
    returns a Lua function as a first-class value. It can take either 
    a string (which is then compiled) or a function (which is simply 
    returned). 

           =Deal(100,10)  
        Your APL system is now stoned
           print(lua(Define"∇?"))  -- see comment below
        return Deal
           Deal=Execute"∇?"        -- recovery!
           =Deal(100,10)
        (85,41,79,81,92,24,38,3,34,60)

    Note that `apl"∇?"` does not return `Deal`, it returns a niladic
    function whose body is `return Deal`; that's why we nead `Execute`. 

`⍎` (`Execute)
~   Does `Define` and returns the value of the function thus constructed
    after calling it with no arguments.

`⍞`,`⎕` (`Read`,`Do`,`Print`)
~   Although implemented as Lua functions, these are not really functions 
    from the APL point of view, they are variables with special semantics. 
    `⍞←x` or `⎕←x` causes the value `x` to be printed. When used as
    a value, not being assigned to, `⍞` stands for the string you will 
    be prompted to type in and `⎕` for the result of executing that string.
    
`lua`
~   Returns the Lua code to which a function has been compiled.
 
`register`
~   Registers a Lua function for use by the compiler. See 
    [Extending Lua⋆APL]. The interface may change more quickly than 
    this manual. `help(register)` should give up-to-date instructions.

APL functions not documented here
---------------------------------

The Wikipedia article <en.wikipedia.org/APL_Syntax_and_Symbols> does an
excellent job, and Lua⋆APL is designed to be downwards compatible with 
the sections "Monadic Functions", "Dyadic Functions" and "Operators" 
from a snapshot of that page made on 12 April 2013.

There are all sorts of little incompatibilities between one APL system
and the next, and Lua⋆APL is no exception. These mainly deal with extra
features that are not quite standard. An APL reference manual for 
whatever implementation would nevertheless not be totally useless. 

The interactive help is the only documentation that is intended to be 
kept in sync with the code. You can print out a complete quick reference
as follows:
 
       apl:import()
       for k in help(apl,1):match":(.*)":gmatch"%S+" do 
          if k:match"^_" or k=="NaN" then h=help(k,1) 
          else h=help(apl[k],1)         
          end
          if (not h or h:match"^That's nil") then 
             print ("No help on'"..k.."', report this please")
          else print(h)
          end
       end

Complete syntax of Lua⋆APL
--------------------------

The actual grammar is spcified in LPeg in `apl-compiler.c` and may by
now be a little different from what you read below. It allows neutral 
whitespace and specifies the Lua code to which a pattern match is 
translated. Both of these have here been suppressed in the service 
of legibility.

The capitalized names are terminals which, for the same reason, I prefer
to describe in English.

---------- -- ---------------------------------------------------
`Param`       `⍺` or `⍵`
`String`      A Lua string delimited by single-quotes
`Var`         A Lua name or a single UTF-8 character
`Vector`      APL-formatted numbers separated by blanks
---------- -- ---------------------------------------------------

`String` and `Var` are subject to exceptions.

-   As currently implemented, a String may not contain a single-quote 
    or a statement separator `⋄`.
-   `Var` is any name that has not been listed as a function, an 
    operator, or a parameter.  Monadic and dyadic functions and 
    operators have names just like the names allowed for variables, 
    which are only special because they appear in lists kept by the 
    compiler. Those lists are not static. The user can add new items 
    to them at run time (see [Extending Lua⋆APL]); once a name has been 
    added to a list, it cannot be removed.

Users familiar with BNF should have no difficulty reading this grammar,
with the following hints:

-   `*` means that the two elements are adjacent
-   `+` means that the two elements are alternatives, tried in
    left-to-right order

For example, an expression can consist of just a single variable name
(since a variable is a value, and a value is a left argument), but this
possibility is only tried when all the other possibilities for an
expression have failed.

A simplified version of that grammar is given below. The full grammar,
complete with compilation captures and special cases, is contained in 
the table `apl_expr` in the module file `lua.apl`. 

    statement = '←'*expr 
      + Param*'←'*expr 
      + Param*"["*indices*"]"*'←'*expr
      + expr;
    expr = '∇'*func_expr
      + Var*'←'*expr
      + Var*"["*indices*"]"*'←'*expr 
      + leftarg*dyadic_func*expr 
      + monadic_func*expr
      + leftarg;
    dyadic_func = ambivalent + Dyadic_function;
    monadic_func = ambivalent + Monadic_function;
    func_expr = '('*(dyadic_func+Monadic_function)*')'
      + Dyadic_function + Monadic_function;
    ambivalent = func_expr*Monadic_operator
       + func_expr*Dyadic_operator*func_expr;
    leftarg = value + '('*expr*')';
    value = Vector + String +
       Var*'['*indices*']' + Var + 
       Param*'['*indices*']' + Param;
    index = expr+"";
    indices = index*';'*index + expr;

Extending Lua⋆APL
-----------------

One can extend APL for particular applications. Here is an example.

In Matlab one finds a very convenient function named `diag`, which
converts between a diagonal matrix and a vector. Let's code a simplified
version of it in Lua and teach APL to use the function. There's a very
convenient unused UTF-8 character available for the name.

       do
       local rho = apl.util.rho
       local argcheck = apl.util.argcheck
       local shape = apl.util.shape
       local min = math.min 

       local function diag(A)
          local m,n = shape(A)
          if not m then return A end
          if n then 
             n=min(m,n)
             res=rho(0,n)
             for k=1,m do res[k]=A[{k,k}] end
             return res
          end
          res=rho(0,m,m)
          for k=1,m do res[{k,k}]=A[k] end
          return res
       end

       apl.register(1,diag,'⍂','Diag')
       end -- do

       print(apl"⍂1 2 3 4 5"())
    1 0 0 0 0
    0 2 0 0 0
    0 0 3 0 0
    0 0 0 4 0
    0 0 0 0 5
       print(apl"⍂(⍳6)∘.×⍳6"())
    1 4 9 16 25 36

Notes:

The functions in `apl.util` are listed in the [List of Lua⋆APL functions].

APL mode
========

The APL standalone interpreter gives an approximation to APL's
look-and-feel. Here is a sample session.

    $ lua-apl 
    Lua 5.2.2  Copyright (C) 1994-2013 Lua.org, PUC-Rio
    Lua⋆APL 0.3.0 © Dirk Laurie 2013
    apl-lib 0.3.0 © Dirk Laurie 2013
    Bug reports are welcome. You'll find me on Lua-L.
    If you can't remember the README, do this:
      apl:import(); help'start'
    --
       apl:import()
       help'APL'
    Contents:  ! + , . / < = > ? \ ¨ × ÷ ← ↑ ↓ ∇ ∊ − ∘ ∣
    ∧ ∨ ∼ ≠ ≡ ≤ ≥ ⊂ ⊃ ⊖ ⊤ ⊥ ⋆ ⌈ ⌊ ⌹ ⌽ ⌿ ⍀ ⍉ ⍋ ⍎ ⍒ ⍕ ⍟ ⍪ ⍱ ⍲ ⍳ ⍴ ⎕ ○ 
       help'⌽'
    Reverse2(⍵): ⌽⍵ → columns of ⍵ in reverse order
    Rotate2(⍵,⍺): ⍺⌽⍵ → elements in rows of ⍵ rotated left by ⍺ or right by -⍺
       ⍺←⍳5 ⋄ ←A←⍺∘.×⍺
     1  2  3  4  5
     2  4  6  8 10
     3  6  9 12 15
     4  8 12 16 20
     5 10 15 20 25
       5 ¯5↑A[2 3;3 2]
    0 0 0 6 4
    0 0 0 9 6
    0 0 0 0 0
    0 0 0 0 0
    0 0 0 0 0
       1 3 2 4 5⌽A
     2  3  4  5  1
     8 10  2  4  6
     9 12 15  3  6
    20  4  8 12 16
     5 10 15 20 25

This is pretty standard APL, but some points deserve mention:

-   The diamond separator `⋄` is supported. It is necessary in this
    case because `⍺∘.×(⍺←⍳5)` is invalid in Lua⋆APL.
-   The parameter names (`⍺` and `⍵`) are available for temporary
    values. Other assignments go into the APL global namespace, or
    even the Lua global namespace (see [Namespaces]).
-   Every input line translates to a single APL function. If that line
    contains a separator, you must explicitly put in a unary assignment
    `←` if you want the function to return something. If there is no 
    separator, the value of the sole APL expression is returned.
-   The jot (`∘`) is mapped to the Lua function `Pass`, which throws
    away all its arguments and returns nothing. This can be used to 
    suppress printout of one-expression inputs. Implementing jot as
    a function also removes the need for the compiler to have 
    a separate syntax for the outer product.

Some other important points have not been illustrated in the short sample.

-   The APL-enabled Lua interpreter pre-empts all the command-line
    parameters of the standard Lua interpreter. You cannot redirect 
    to its input, and script files cannot be processed. For that, you
    must use the compiler explicitly from Lua.

-   Heuristics are used to guess whether an input chunk is APL. These
    change so often that I don't document them outside `lua-apl.c` any
    more. Ideally, it should not bother anybody: it is very hard to
    invent a character string that could parse to either correct APL or
    correct Lua, so it ought to be very easy to see at a glance, even a
    computer's glance, which it is.

    The comments in `lua-apl.c` (search for "guess") include tips on how
    to override a wrong guess.

-   If you replay input history (assuming your Lua has that feature) you
    will notice that your input has been changed to what you would have
    typed in Lua mode, e.g. `2 3⌽A` turns into `return apl"2 3⌽A"()`.


