<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<style type="text/css">
  code{white-space: pre; background-color: #F1F1F1;}
</style>

<h1 id="luaapl-users-manual">Lua⋆APL User's Manual</h1>
<p>© Dirk Laurie 2013 Lua-style MIT licence</p>
<p>What it says in the README about installation and UTF-8 is not repeated here.</p>
<p>APL is a functional language with extensive array processing abilities, originally designed by Ken Iverson in the 1960's. Lua⋆APL is an extension of Lua that gives access to the power of APL (the APL asterisk <code>⋆</code> means <code>Power</code>) without leaving the comfort and security of Lua.</p>
<p>There are three modes of usage, which can be thought of as analogous to the C API, scripting language, and standalone executable of Lua.</p>
<ul>
<li><p>Library mode: APL functionality is offered as a Lua library, which makes no use of the APL character set except in its help information.</p></li>
<li><p>Lua mode: Functions callable from Lua can be written in APL. This is achieved via a function rather like Lua's <code>load</code>, which generates intermediate Lua code consisting of chained calls to the APL library.</p></li>
<li><p>APL mode: Bare APL code can be entered direcctly at the terminal, mixed with Lua code. Because APL code has such a distinctive appearance, even a primitive guessing algorithm can identify it with a high rate of accuracy. Code deemed to be APL is translated to load and execute as in Lua mode, but the result is printed by default as typical APL systems do. The effect is to give an APL-like look-and-feel. If you already know APL, jump straight to that section and try it out.</p></li>
</ul>
<p>The code examples shown here, even the ones in the section on Lua mode, use the three-space prompt of the Lua⋆APL standalone rather than the conventional Lua prompt, but all code except that shown in the section on <a href="#apl-mode">APL mode</a> works on a vanilla Lua interpreter too.</p>
<p>In this document, we do not consistently use &quot;APL&quot; and &quot;Lua⋆APL&quot; as denoting different things. &quot;APL&quot; is a fairly vague term, meaning more or less &quot;a typical APL implementation&quot; or even &quot;the APL way of thinking&quot;, whereas &quot;Lua⋆APL&quot; is a specific term for this implementation, which of course also falls under the shadowy APL umbrella.</p>
<p>Words like &quot;standard&quot; refer to features that are typically found in almost every APL dialect since about 1980, well summarized in the <a href="http://en.wikipedia.org/wiki/APL_syntax_and_symbols">Wikipedia article</a>. &quot;Non-standard&quot; in the case of Lua⋆APL means that I am using an unusual APL symbol without making any attempt even to find out how modern APL implementations use it (the latest APL that I take into account is APL2, and even in that case compatibility across the board is not aimed at). Please contact me if you feel that some other symbol for the same concept, or some other concept for the same symbol, is actually semi-standard by now.</p>
<p>If you would like to know much more about APL than you currently do, there are several well-organized websites of modern commercial APLs, e.g. <a href="http://www.microapl.com/apl_help">http://www.microapl.com/apl_help</a>.</p>
<p>When I wrote this line, the version number displayed by the start-up message was <code>0.3.0</code>. As long as the first number is <code>0</code>, anything might still change.</p>
<h1 id="library-mode">Library mode</h1>
<p>This mode requires the module <code>apl-compiler</code>, which loads a C module <code>apl_core</code> that is documented in the Programmer's Guide. Even though I do not expect anybody to stop at library mode, it is the easiest place to start for Lua programmers who do not know any APL. It is best learnt in an interactive session because an extensive amount of interactive help is available.</p>
<p>I'm assuming you loaded the module by</p>
<pre><code>   apl=require&#39;apl-lib&#39;
   apl:import&#39;*&#39;</code></pre>
<p>That call to <code>apl:import</code> adds the 70-plus items of the module to the global environment. Almost all of them are quite distinctively named, but if you instinctively recoil in horror, muttering &quot;pollution&quot; under your breath, by all means omit that line and prepare to type numerous instances of <code>apl.</code>, or (in a script) replace it by assigning the ones you actually use to local variables. Better, actually: just hold your horses till you get to Lua mode; no large-scale imports necessary there.</p>
<p>A thorough knowledge of what the library offers is not needed if you already know APL and plan to use mostly APL mode. If you already know APL, by all means skip straight to <a href="#apl-mode">APL mode</a> and only read this part later.</p>
<p>The module returns a table with keys named by the following convention:</p>
<ul>
<li><code>CamelCase</code>: APL functions (mostly mapped to APL symbols later)</li>
<li><code>lowercase</code>: Lua functions (not usually called from APL code)</li>
<li><code>_CAPS</code>: needed by the system or providing information</li>
</ul>
<p>&quot;APL functions&quot; of course does not imply that they are anything else than just Lua functions. It merely means that these are mostly the functions that lie at the heart of APL, closely following the original design of Iverson. There is a simple mapping between Lua postfix notation and APL infix notation, for example:</p>
<table>
<thead>
<tr class="header">
<th align="center">Lua</th>
<th align="left"></th>
<th align="center">APL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>_w</code></td>
<td align="left"></td>
<td align="center"><code>⍵</code></td>
</tr>
<tr class="even">
<td align="center"><code>_a</code></td>
<td align="left"></td>
<td align="center"><code>⍺</code></td>
</tr>
<tr class="odd">
<td align="center"><code>func(_w,_a)</code></td>
<td align="left"></td>
<td align="center"><code>⍺ func ⍵</code></td>
</tr>
<tr class="even">
<td align="center"><code>Range(_w)</code></td>
<td align="left"></td>
<td align="center"><code>⍳⍵</code></td>
</tr>
<tr class="odd">
<td align="center"><code>Find(_w,_⍺)</code></td>
<td align="left"></td>
<td align="center"><code>⍺⍳⍵</code></td>
</tr>
<tr class="even">
<td align="center"><code>Shape(_w)</code></td>
<td align="left"></td>
<td align="center"><code>⍴⍵</code></td>
</tr>
<tr class="odd">
<td align="center"><code>Reshape(_w,_a)</code></td>
<td align="left"></td>
<td align="center"><code>⍺⍴⍵</code></td>
</tr>
<tr class="even">
<td align="center"><code>Decode(_w,_a)</code></td>
<td align="left"></td>
<td align="center"><code>⍺⊤⍵</code></td>
</tr>
<tr class="odd">
<td align="center"><code>Add(_w,_a)</code></td>
<td align="left"></td>
<td align="center"><code>⍺+⍵</code></td>
</tr>
<tr class="even">
<td align="center"><code>Sub(_w,_a)</code></td>
<td align="left"></td>
<td align="center"><code>⍺-⍵</code></td>
</tr>
<tr class="odd">
<td align="center"><code>Mul(_w,_a)</code></td>
<td align="left"></td>
<td align="center"><code>⍺×⍵</code></td>
</tr>
<tr class="even">
<td align="center"><code>Div(_w,_a)</code></td>
<td align="left"></td>
<td align="center"><code>⍺÷⍵</code></td>
</tr>
</tbody>
</table>
<p>In total, over 70 of these functions are provided in Lua mode. The APL symbols used for them, even those which in Lua denote arithmetic operators, must be thought of as names, not as as special characters, even though those names are not used in library mode.</p>
<p>One and the same APL name often does duty for two Lua names. This is possible because APL infix syntax allows the compiler to distinguish between monadic and dyadic functions (see <a href="#valence">Valence</a>) and select the appropriate function. That distinction is possible in Lua too, but only at run time, when one can test whether the second argument of a function is present and not nil.</p>
<p>APL syntax makes the distinction already at compile time, so that overloading of the Lua names of the functions is not necessary. Instead, the names have been chosen to be descriptive of what the functions do.</p>
<p>Some semi-standard descriptive names are often used in APL documentation, such as <a href="http://en.wikipedia.org/wiki/APL_syntax_and_symbols">http://en.wikipedia.org/wiki/APL_syntax_and_symbols</a>. These have been retained in some cases (<code>Ravel</code>, <code>Reshape</code> etc), abbreviated in others (<code>Exp</code> rather than <code>Exponential</code> etc), and occasionally replaced by totally different names (<code>Pow</code> rather than <code>Exponentiation</code>). Functions corresponding to Lua arithmetic metamethods have been given basically the same name (<code>Unm</code> for unary minus, etc.) but there's no rule, really; I've done what feels programmer-friendly to me.</p>
<p>The documentation, in particular the interactive help, freely uses both the Lua names and APL symbols simultaneously, so you will acquire a smattering of APL more or less painlessly even while using library mode only.</p>
<h2 id="apl-types-and-lua-types">APL types and Lua types</h2>
<p>An APL-like type structure consisting of functions, operators, scalars, vectors and matrices is implemented via Lua values.</p>
<p>The APL terms &quot;function&quot; and &quot;operator&quot; are used in a different sense than in Lua. The symbols for arithmetic, comparison etc are called &quot;operators&quot; in Lua and the parser treats them by strict precedence rules. In APL, those symbols are names of functions (many of them are actually three-byte names that only look like a single character thanks to UTF-8), there is no notion of precedence, and &quot;operator&quot; means a function that acts on functions.</p>
<ul>
<li><p>APL functions are Lua functions of two variables, returning one return value. In the documentation, the names <code>⍺,⍵</code> and <code>_a,_w</code> are used respectively when the function is called from APL or from Lua. The <em>left</em> argument <code>⍺</code> in APL infix notation becomes the <em>second</em> argument <code>_a</code> in Lua postfix notation. In APL, the parser can see whether <code>⍺</code> is omitted; in Lua, providing <code>_a</code> as nil is equivalent to omitting it.</p></li>
<li><p>APL operators are also Lua functions of two variables, but:</p>
<ol style="list-style-type: decimal">
<li><p>Their arguments and return value are functions.</p></li>
<li><p>In the documentation, the first argument is called <code>f</code> and the second <code>g</code> in the documentation of both APL and Lua.</p></li>
<li><p>The <em>left</em> argument <code>f</code> in APL infix notation becomes the <em>first</em> argument <code>f</code> in Lua postfix notation and must always be present; the (right) second argument <code>g</code> is usually absent, <code>Inner</code> being the only function in <code>apl-lib</code> that uses it.</p></li>
<li><p>Operators have a higher priority than functions.</p></li>
</ol></li>
<li><p>APL arrays (vectors and matrices both) are Lua index-1 tables. The ordering of matrix elements is row-wise. More on this in a while.</p></li>
<li><p>APL scalars are Lua numbers and strings. Other Lua types are treated as scalar. In particular, a Lua function is an APL scalar. This point, too, will be elaborated on.</p></li>
</ul>
<p>APL arrays share a common metatable. Numeric keys in the simplest case obey the same conventions as the Lua table library: the positive integer keys of <code>A</code> are expected to form a solid block from 1 to <code>#A</code>. The full truth is more complicated; see <a href="#array-operations">Array operations</a> and <a href="#indexing">Indexing</a>.</p>
<p>String keys are used to achieve the extra functionality of APL arrays:</p>
<dl>
<dt><code>A.apl_len</code></dt>
<dd>Optional field. If present, this is the value returned by the Lua <code>#</code> operator.
</dd>
<dt><code>A.rows, A.cols</code></dt>
<dd>Number of rows and columns (matrix only).
</dd>
</dl>
<p>It is possible to synthesize an APL array in vanilla Lua. However, it is not recommended, and never necessary, for two reasons:</p>
<ul>
<li>In almost all cases, the APL library will accept a Lua table as a substitute for an APL vector.</li>
<li>All tables returned by the library are APL arrays. In particular, the function <code>Copy</code> will convert a Lua to an APL array.</li>
</ul>
<p>For example, to define a matrix (see <a href="#formatting">Formatting</a> for <code>_format</code>):</p>
<pre><code>   apl._format = &#39;raw&#39;          
   A = Reshape({11,12,13,21,22,23},{2,3})   
   print(A)
[11,12,13;21,22,23]
   print(Ravel(A))
(11,12,13,21,22,23) </code></pre>
<p>The <em>rank</em> of an array is the number of indices it takes to reference an element from it. APL allows rank 0 (scalar), rank 1 (vector) and rank (matrix). APL does not distinguish between row vectors and column vectors; if you need to do that, use a one-row or one-column matrix.</p>
<p><code>Shape</code> is the APL analogue of Lua's <code>type</code>, defined as follows:</p>
<ul>
<li>number: <code>Shape(a) = {}</code></li>
<li>vector: <code>Shape(x) = {#x}</code></li>
<li>matrix: <code>Shape(A) = {A.rows,A.cols}</code></li>
<li>string: <code>Shape(s) = #s</code></li>
<li>other scalar: <code>Shape(other) = nil</code></li>
</ul>
<p>It should be stressed that APL matrices are not tables of tables, they are simple tables that carry shape information.</p>
<p>Lua userdata values are also APL scalars. If equipped with the right metamethods, they might work inside APL expressions, but this possibility is unexplored.</p>
<h2 id="formatting">Formatting</h2>
<p>APL normally uses a pretty-printing output format.</p>
<pre><code>   print(Reshape({11,12,13,21,22,23},{2,3}))
11 12 13
21 22 23
   </code></pre>
<p>While nice-looking, this format makes it hard to notice the subtle distinctions that we will need to make in this manual, and therefore we have in many of the examples used raw format. The Lua⋆APL <code>Format</code> function in general takes two arguments. If the second argument is absent, the <code>_format</code> field in the module table is interrogated. Since the module table is not read-only, the user can assign something to <code>apl._format</code>. The value <code>&quot;raw&quot;</code> selects one-line output with the following conventions:</p>
<ul>
<li>undelimited: scalars</li>
<li>delimited by braces: {Lua,table}</li>
<li>delimited by parentheses: (APL,vector)</li>
<li>delimited by brackets: [APL,matrix;semicolons,separate,rows]</li>
</ul>
<p>Not-a-number is printed as <code>NaN</code> and nil as an underscore.</p>
<pre><code>   print(Format{1,nil,0/0,&quot;abc&quot;})
{1,_,NaN,&#39;abc&#39;}</code></pre>
<p>The <code>Format</code> function works recursively until the result is a string.</p>
<h2 id="array-operations">Array operations</h2>
<p>The whole point of using APL is so that one never (well, hardly ever) needs to use an explicit table index. The vast majority of its functions accept array arguments and return array values.</p>
<p>The APL library handles nil arguments gracefully in the case of all scalar functions (i.e. functions that apply term-by-term to array arguments).</p>
<pre><code>   x=Copy{1,2,nil,4}; y=Rev(x)
   print(Add(x,y))
{5,_,_,5}</code></pre>
<p>The actual storage of a very sparse vector will be compact, using mostly the hash part of a Lua table, but there is no true optimized support for sparse vectors. The functions simply iterate over the known length of the array and skip nils.</p>
<h3 id="indexing">Indexing</h3>
<p>APL arrays have a fixed size, which is frozen for a given Lua table <code>tbl</code> by setting its metatable to the APL array metatable. The <code>__index</code> and <code>__newindex</code> metamethods then come into play whenever an attempt is made to access any index except those which are actually in use. Conversely those metamethods are <em>not</em> invoked in the case of a valid numeric index.</p>
<p>In particular, an element of a matrix can be accessed by giving only one index. Matrices are stored row by row.</p>
<ul>
<li>A nonexistent numeric or string index is illegal.</li>
<li>If you assign nil to an numeric or string index, that index thenceforth becomes unavailable permanently, no matter what <code>apl_len</code> is.</li>
<li>A legal numeric index to a matrix indexes it as a vector.</li>
<li>A table-valued index to a vector should either be an APL vector (Lua array acceptable) or an APL matrix (Lua array with <code>rows</code> and <code>cols</code> set acceptable). The result will have the same shape as the index.</li>
<li>A table-valued index to a matrix should be a pair of items, each of which may be a number or a Lua array (APL vectors and matrices are acceptable, but lose their magic powers) which select the rows and columns. The result will have rank determined by the index types, and shape determined by the lengths of the lists.</li>
<li>A function-valued index should be an iterator that returns a valid numeric index until it returns nil. The array being indexed is treated as a vector, and the result is always a vector.</li>
</ul>
<p>The two metamethods are available in the library as <code>Get</code> and <code>Set</code>, and can be invoked explicitly, even with ordinary non-APL tables. You should only do that with a function-valued or table-valued index, because you are bypassing the Lua indexing mechanism. Other indices are passed to routines normally called only for nonexistent indices; the routines know that a scalar index that gets this far must be invalid, and throw an error.</p>
<pre><code>   x={1,2,3,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;}
   y={10,20,30,A=&#39;a&#39;,B=&#39;b&#39;,C=&#39;c&#39;}
   print(Get(x,{5,2,4}))
(&#39;B&#39;,2,&#39;A&#39;)
   Set(y,Get(x,{5,2,4}),{100,200,300})
   print(y)
table: 0x93e4e90
   print(Copy(y),y.A,y.B)
(10,200,30)     300     100
   Get(y,1)  -- index not a function or a table: trouble!
./apl-lib.lua:520: bad argument #2 to &#39;core_index&#39; (index out of range)</code></pre>
<h3 id="nested-arrays">Nested arrays</h3>
<p>The elements of an APL array may be themselves be arrays, since the inner structure of an element is opaque to APL, i.e. APL thinks of anything stored in an array as scalar.</p>
<pre><code>   A={{1,2},{3,4},{5,6}}; print(Format(A))
{{1,2},{3,4},{5,6}}
   B=Copy(A); print(B)         
({1,2},{3,4},{5,6})            
   print(A[1]==B[1])
true</code></pre>
<p>That <code>true</code> says that <code>A[1]</code> and <code>B[1]</code> are actually one and the same table: the elements are still the original Lua tables. This is not quite what is usually wanted from a routine called <code>Copy</code>. The operator <code>Each</code> applies a function term-by-term to every element of a table and returns a new array with the same shape as the original.</p>
<pre><code>   C=Each(Copy)(A); print(C)
((1,2),(3,4),(5,6))</code></pre>
<p>The elements are now newly minted APL arrays, as is the containing array.</p>
<p><code>Each</code> works equally well for monadic and for dyadic functions. The APL compiler can tell the difference.</p>
<pre><code>   print(Each(Reshape)({{1,2,3,4},{5,6,7,8}},{{2,2}}))
([1,2;3,4],[5,6;7,8])</code></pre>
<p>In this example, the two arguments are both nested arrays, so they look to APL like a two-element and a one-element array. A dyadic function created by <code>Each</code> expects two arrays of compatible shape for term-by-term operations, but will accept a one-element argument to act as a constant value. You can override that permission by supplying extra parameters to <code>Each</code> (this feature is only available when calling <code>Each</code> from Lua; the APL operator <code>¨</code> does not allow the possibility.).</p>
<pre><code>   print(Each(Add)({{1,2,3,4},{5,6,7,8}},{1}))
(2,3,4,5) (6,7,8,9)
   print(Each(Add,true,false)({{1,2,3,4},{5,6,7,8}},{1}))
./apl-lib.lua:497: bad argument #3 to &#39;both&#39; (shapes are incompatible)</code></pre>
<p>A vector of vectors of the same length can be combined into a matrix, and a matrix can be converted to a nested array. These operations are so commonly needed that the APL2 notations <code>⊂</code> (Enclose) and <code>⊃</code> (Disclose) have been borrowed (but not with the exact same meaning), and the non-standard APL function <code>Rerank</code> has have been invented as an umbrella for them in library mode.</p>
<pre><code>   help&quot;⊂&quot;
Enclose: ⊂⍵ makes an array of rows from a matrix
   help&quot;⊃&quot;
Disclose: ⊃⍵ makes a matrix from an array of rows. Each ⍵[i] is treated as
a vector and padded to the maximum length using zeros or empty strings.
   help(Rerank)
Rerank: Rerank(_w,_a): array of one rank higher (_a&gt;0) or lower (_a&lt;0),
   stacking rows (±1) or columns (±2). See Disclose/Enclose.</code></pre>
<h3 id="axis-dependent-functions-and-operators">Axis-dependent functions and operators</h3>
<p>Several APL vector functions generalize to matrices by operating either on the rows or on the columns. In APL notation, the distinction is made by using different symbols (<code>⊖ ⌿ ⍀ ⍪</code> are the row-wise counterparts to <code>⌽ / \ ,</code>). In library mode, there is no need to avoid an extra axis argument, and so there is only one function name.</p>
<pre><code>   help(Attach)
Attach(⍵,⍺): ⍺,⍵ → elements of ⍺ followed by elements of ⍵
Attach(⍵,⍺,1): ⍺⍪⍵ → rows of ⍺ followed by rows of ⍵
Attach(⍵,⍺,2): ⍺,⍵ → columns of ⍺ followed by rows of ⍵
  In the matrix cases, vectors are treated as one-row matrices.
   print(Attach({1,2},{3}))
(3,1,2)
   print(Attach({1,2},{3},1))
[3,0;1,2]
   print(Attach({1,2},{3},2))
[3,1,2]</code></pre>
<p>As you can see, Lua⋆APL's <code>Attach</code> pads short rows or columns to the length of the longest list.</p>
<p>In Lua⋆APL, the principle is &quot;act on rows when the axis is 1, act on colums when the axis is 2&quot;, and the implementation is to convert the matrix to a nested array, do something to that nested array, and convert back.</p>
<p>In the case of <code>Rotate</code>, there is a possibility of confusion here. <code>Rotate(A,1,1)</code> must rotate the rows of <code>A</code> up by 1, no question. What does <code>Rotate(A,{2,1,3,4},1)</code> do, rotate each row of <code>A</code> individually by the specified amount? If so, <code>Rotate(A,{1,1,1,1},1)</code> would rotate every row left by 1, i.e. it would rotate the columns left by 1. That would violate the APL principle that a singleton does the same as a constant vector. So we must violate the Lua⋆APL principle for the sake of the greater cause: <code>Rotate(A,{2,1,3,4},1)</code> rotates each <em>column</em> of <code>A</code> individually by the specified amount.</p>
<p>For later use by the APL compiler, specialized versions of these functions have been made with the axis argument fixed. These are available in library mode with a little extra trouble, but not in Lua or APL mode. That's why the prompts are the usual Lua prompts.</p>
<pre><code>&gt; print(apl._F.Attach1({1,2},{3}))
[3,0;1,2]
&gt; print(apl._F.Attach2({1,2},{3}))
[3,1,2]</code></pre>
<h3 id="high-level-matrix-functions">High-level matrix functions</h3>
<p>The APL functions <code>MatDiv</code> and <code>MatInv</code> are calculated with the aid of the so-called &quot;economy-size&quot; singular value decomposition of a matrix. This represents the matrix as</p>
<pre><code>A = Inner(Add,Mul)(Each(Outer(Mul))(V,U),S)</code></pre>
<p>where <code>S</code> contains the singular values, and <code>U</code> and <code>V</code> the left and right singular vectors, of <code>A</code>. Or <code>S+.×U(∘.×)¨V</code> in APL notation.</p>
<p>In library mode, the function <code>SVD</code> has been provided for the convenience of those who have use for these intermediate quantities. Its return value is a Lua table with the fields <code>S</code>, <code>U</code> and <code>V</code>. Each of these tables is a userdata with an <code>apl</code> method which returns an APL vector of length <code>m</code>, where <code>m</code> is the numerical rank of <code>A</code>. That is to say, <code>U:apl()</code> and <code>V:apl()</code> are nested arrays.</p>
<p>The numerical rank depends on the comparison tolerances (see <a href="#global-control-variables">Global control variables</a>). Specifically, the elements of <code>s=S:apl()</code> are positive numbers in nonincreasing order; if <code>_act</code> is nonzero, elements less than <code>_act</code> count as zero; if <code>_rct</code> is nonzero, elements less that <code>_rct*s[1]</code> count as zero.</p>
<h2 id="strings">Strings</h2>
<p>Lua⋆APL does not have character arrays, any more than Lua itself has them. A string is a scalar. If you need to operate on individual bytes of a string, the Lua function <code>string.byte</code> combines well with the library.</p>
<pre><code>   tobytes = function(s) return {s:byte(1,-1)} end
   frombytes = function(s) return string.char(unpack(s)) end
   M=Each(tobytes){&quot;The&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;}; print(M)
({84,104,101},{113,117,105,99,107},{98,114,111,119,110},{102,111,120})
   print(Each(frombytes)(M))
(&#39;The&#39;,&#39;quick&#39;,&#39;brown&#39;,&#39;fox&#39;)</code></pre>
<p>Library mode knows no UTF-8. If you need to operate on individual UTF-8 codepoints, see <a href="#lua-mode">Lua mode</a>.</p>
<h2 id="classification-of-functions">Classification of functions</h2>
<p>Part of the appeal of Iverson's design is the cogent uniformity of the behaviour of APL functions. Most functions fall in one of a small number of classes.</p>
<p>NB <em>This section will change a lot.</em> It does not describe either the status quo or what is planned, just some random thoughts around the topic.</p>
<h3 id="primitive-scalar-functions">Primitive scalar functions</h3>
<p>About one-half of all APL functions give scalar results when applied to scalars, and are applied term-by-term to arrays, giving an array of the same shape.</p>
<p>In the case of dyadic functions, it is a little more complicated, but the same for all of them.</p>
<ul>
<li>The arguments must have compatible shapes, and the result has the shape of the argument with higher rank.</li>
</ul>
<p>&quot;Compatible&quot; means one of the following conditions hold:</p>
<ul>
<li>The arguments have the same shape.</li>
<li>At least one argument is a singleton (i.e. has exactly one element).</li>
<li><p>One argument is a one-row or one-column matrix, and the other a vector or a Lua table of the same length.</p>
<pre><code>   x=Reshape(Range(10),{1,10}); print(x)
[1,2,3,4,5,6,7,8,9,10]
   y=Reshape({1,-1},10); print(y)
(1,-1,1,-1,1,-1,1,-1,1,-1)
   print(Mul(x,y))
[1,-2,3,-4,5,-6,7,-8,9,-10]</code></pre></li>
</ul>
<p>A few functions give vector results when applied to scalars. In Lua⋆APL, they can be applied to arrays, following the same rules as primitive scalar functions, but yielding nested arrays.</p>
<pre><code>       print(Range{10,7})
    ((1,2,3,4,5,6,7,8,9,10),(1,2,3,4,5,6,7))
       print(Deal({10,100},{10,7}))
    ((1,3,6,9,8,4,7,5,10,2),(89,14,100,9,88,12,7))</code></pre>
<h3 id="primitive-vector-functions">Primitive vector functions</h3>
<p>A vector is treated as a whole, not term-by-term.</p>
<pre><code>Decode Down Encode Find Has Reverse Rotate Same Up  </code></pre>
<h3 id="rank-changing-functions">Rank-changing functions</h3>
<pre><code>Attach Ravel Rerank Reshape </code></pre>
<h3 id="selectors">Selectors</h3>
<pre><code>Compress Compress1 Drop Expand Expand1 Get Set Shape Take </code></pre>
<h3 id="matrix-functions">Matrix functions</h3>
<pre><code>MatDiv MatInv Transpose</code></pre>
<h3 id="operators">Operators</h3>
<pre><code>Each Inner Outer Reduce Scan</code></pre>
<h2 id="global-control-variables">Global control variables</h2>
<p>APL traditionally makes use of some control variables that affect its overall behaviour. Which these are, differs from one APL implementation to the next, so they are sometimes called &quot;system variables&quot;. In Lua⋆APL, their names start with an underscore, and they are stored in the module table.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><code>_act</code></td>
<td align="left"></td>
<td align="left">Absolute comparison tolerance.</td>
</tr>
<tr class="even">
<td align="left"><code>_rct</code></td>
<td align="left"></td>
<td align="left">Relative comparision tolerance.</td>
</tr>
<tr class="odd">
<td align="left"><code>_format</code></td>
<td align="left"></td>
<td align="left">Default format for monadic <code>Format</code>.</td>
</tr>
</tbody>
</table>
<dl>
<dt>Comparison tolerance</dt>
<dd><p>Lua⋆APL does a straightforward comparison only in the case of functions that don't test for equality (<code>TestNE</code>, <code>TestGT</code>, <code>TestLT</code>). Functions that give 1 in the equality case (<code>TestEq</code>, <code>TestGE</code>, <code>TestLE</code>) actually test for approximate equality. Either of <code>abs(_a-_w)&lt;apl._act</code> and<code>abs(_a-_w)&lt;apl._rct*abs(_w)</code> also counts as equality if the corresponding control variable is defined,</p>
<p>The philosophical implications are mind-blowing (<code>TestEq(x,y)</code> may not give the same result as <code>TestEq(y,x)</code>, etc) but the practical effect is that with the default settings, the equality tests do what most sane people (that excludes numerical analysts, of course) expect them to. If you don't want them, you can always set those tolerances to zero or nil, or just do the complementary test (<code>1-TestNE(x,y)</code> etc).</p>
<pre><code>   s=1/7; t=s+s+s+s+s+s+s; print(1==t)
false
   print(TestGE(1,t))
1
   apl._act=0; apl._rct=0
   print(TestGE(1,t))
0</code></pre>
</dd>
</dl>
<h2 id="list-of-luaapl-functions">List of Lua⋆APL functions</h2>
<p>The current version may give a slightly different result, so do the following yourself. For most of these, you can get interactive help.</p>
<pre><code>   help(apl)
Contents: Abs Add And Attach Attach1 Binom Both Ceil Circ Copy Compress
    Compress1 Deal Decode Div Down Drop Each Encode Exp Expand Expand1 Fact
    Find Floor Format Get Has Inner Ln Log Max Min Mod Mul NaN Nand Nor Not
    Or Outer Pass Pi Pow Range Ravel Recip Reduce Reduce1 Rerank Reshape
    Reverse Reverse1 Roll Rotate Rotate1 Same Scan Scan1 Set Shape Sign Sub
    Take TestEq TestGE TestGT TestLE TestLT TestNE Transpose Unm Up _F help
    import util    
   help(Transpose)
Transpose: ⍉⍵ → matrix transpose of ⍵</code></pre>
<p><code>apl._F</code> contains sub-lists of functions for the use of the APL compiler. You can safely ignore it. <code>util</code> contains functions that the compiler will also need. Don't rely on any of those to be present in any future version. If I like them enough to make them available publicly, they will be given CamelCase names.</p>
<h1 id="lua-mode">Lua mode</h1>
<p>This mode requires the module <code>apl-compiler</code>, which loads <code>apl-lib</code>, adds some additional items to the module table, and erases <code>_F</code> and <code>util</code> from it. It is the mode in which to write programs, but makes quite a convenient interactive session too. If you prefer the control and safety of a family car to the breathless excitement of an open-top sports model, you will be happier with Lua mode than APL mode.</p>
<p>I'm assuming you loaded the module by</p>
<pre><code>   apl=require&quot;apl-compiler&quot;
   apl:import()</code></pre>
<p>That call to <code>apl.import</code> puts <code>help</code> and <code>lua</code> in the global environment.</p>
<p>The compiler works as follows:</p>
<ol style="list-style-type: decimal">
<li><p>APL source is split into independent chunks by the <code>⋄</code> (diamond) separator, each of which is compiled on its own. This implies that you are not allowed to use the diamond inside an APL string. You are also not allowed to use the single-quote inside. If you really need those two characters inside a string, create it using Lua and refer to it inside APL by its global name.</p></li>
<li><p>An APL chunk is lexed, parsed and translated to Lua code in one step by a single LPeg grammar. I thank Roberto Ierusalimschy from the bottom of my heart for this absolutely ideal tool.</p></li>
<li><p>The result of the previous step is a chunk of Lua code, which looks exactly like what you would code in Lua mode, and a number identifying the position in the APL code at which the compiler could not continue. If that is before the end of the string, the compilation failed, and the APL code is displayed with an arrow pointing to that position and an error message. This is maybe only slightly more helpful than saying there is an error somewhere, but at least it gives a starting point.</p>
<pre><code>   ⍺∘.×(⍺←⍳5)
./apl-compiler.lua:116: APL syntax error
⍺∘.×(⍺←⍳5)
 ↑</code></pre>
<p>There is nothing wrong with the outer product to which the arrow points. The real error is that assignment to local variables is only allowed at the start of a statement, but the compiler makes no clever second-guessing of common mistakes. All that the arrow says is that <code>⍺</code> by itself would have been legal APL code, but no substring that goes beyond the arrow is legal.</p></li>
<li><p>If the compilation of all the APL chunks succeeded, the Lua chunks produced by the compiler are concatenated; if there was only one chunk, <code>return</code> is put in front of it; the result is tacked onto a standard preamble and the whole lot is processed by <code>load</code>, with the APL runtime environment as fourth argument.</p></li>
<li><p>If <code>load</code> succeeds (which it should, otherwise there is a compiler bug that should be reported), the original APL code is set as the help string for the Lua function, which is returned. The Lua code can be recovered by <code>apl.lua</code>.</p></li>
</ol>
<p>All this is done by calling <code>apl</code> (it is a table, yes, but a callable table), which returns an anonymous function that can be stored or executed.</p>
<pre><code>   sorted_down=apl&quot;⍵[⍒⍵]&quot;
   print(lua(sorted_down))
return _w[Down(_w)]
   x=apl&quot;10?100&quot;()
   print(x)
(49,23,96,93,19,89,67,48,66,35)
   print(sorted_down(x))
(96,93,89,67,66,49,48,35,23,19)</code></pre>
<p>The APL runtime environment has mostly the same keys and values as <code>apl</code>, but it is a different table. You have read-write access to the module table; you have no access to the APL runtime environment. There are certain advantages to this.</p>
<pre><code>   print(apl.Deal(100,10))
(85,41,79,81,92,24,38,3,34,60)
   apl.Deal = function() print&quot;Your APL system is now stoned&quot; end
   print(apl.Deal(100,10))
Your APL system is now stoned
   print(Execute&quot;10?100&quot;)
(49,23,96,93,19,89,67,48,66,35)</code></pre>
<p>I'm not saying that a sufficiently sneaky hacker can't access it — after all, this is open-source code — merely that you can't easily clobber it by accident.</p>
<p>It is possible to write quite long stretches of APL this way, but it is even harder to find a computing task that genuinely requires a long stretch of APL code. What one does need fairly often is a way to separate expressions that belong to the same chunk. The reason is that assigment to the local variables <code>⍺</code> and <code>⍵</code> is only allowed at the beginning of a statement.</p>
<p>The statement separator <code>⋄</code> is used for thus purpose. Also available is the APL comment symbol <code>⍝</code>, which makes everything up to and including the next linebreak invisible to the compiler.</p>
<pre><code>   sievestep=apl[[
      ⍺←⍺×⍳⌊(⍴⍵)÷⍺    ⋄  ⍝ multiples of ⍺ not past end of ⍵
      ⍵[⍺]←0          ⋄                 ⍝ assign 0 to those
      ←⍵      ⍝ explicit return required in multi-statement 
   ]]
   print(lua(sievestep))
_a=Mul(Range(Floor(Div(_a,Shape(_w)))),_a); _w[_a]=0; return _w </code></pre>
<p>You can see from the Lua listing why there is a restriction on where you can assign to a local variable: it gets its own separate Lua statement. On the other hand, assignment into a table, such as the APL or Lua global environment, is implemented as a function call, which can appear anywhere.</p>
<p>However, program logic has not been implemented in APL. You will need mixed-language programming, using Lua for the logic. If the original environment that was active when the library was loaded is still in effect, APL code can see global the Lua variables: see <a href="#namespaces">Namespaces</a>. However, locals and upvalues are invisible, so the process needs some care when used from inside a function.</p>
<p>The canonical APL way is to do everything via named or anonymous functions. Your data is passed in as arguments <code>⍵</code> and <code>⍺</code>, values are returned. If you pass a table, that table itself is mutable.</p>
<pre><code>   function primes(n)
   local x=apl&quot;⍳⍵&quot;(n)
   local step=apl&quot;⍵[1↓⍺×⍳⌊(⍴⍵)÷⍺]←0 ⋄ ←⍵&quot;
   for i=2,math.sqrt(n) do 
      local p=x[i]
      if p and p&gt;0 then step(x,p) end 
   end
   x[1]=0
   return apl&quot;(⍵&gt;0)/⍵&quot;(x)
   end
   print(primes(100))
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</code></pre>
<h2 id="valence">Valence</h2>
<p>In Lua, the number of arguments to a function is no big deal. You supply more arguments than the function was defined with? The others are ignored. You supply fewer arguments than the function was defined with? The missing ones are given the value <code>nil</code>. This behaviour lies at the very heart of the Lua way of thinking,</p>
<p>In APL, the number of arguments to a function is absolutely central. Funtions are <em>niladic</em> (no arguments), <em>monadic</em> (one argument) or <em>dyadic</em> (two arguments). Lua⋆APL syntax does not make provision for niladic functions.</p>
<p>The APL syntax allows the valence of a function to be determined from its context in the expression. Just like Lua knows the difference between unary minus and subtraction, APL knows the difference between monadic and dyadic use of a function symbol — in fact, about 20 APL symbols can be used for either a monadic or a dyadic function, and in almost all cases, those functions are implemented by different Lua functions.</p>
<p>Operators are even more complicated. In principle there are numerous possibilities for the valence of an operator, its arguments and its result. The original APL operators are of two kinds.</p>
<h3 id="monadic-operators">Monadic operators</h3>
<p>A monadic operator acts on a dyadic function (which is the left argument of the operator) to form a monadic function.</p>
<h3 id="dyadic-operators">Dyadic operators</h3>
<p>A dyadic operator acts on a pair of dyadic functions to form a dyadic function.</p>
<p>The implementation is not always as catholic as the above suggests, and some APLs do not allow operators to act on user-defined functions.</p>
<p>Lua*APL, on the other hand, is very permissive. A monadic operator is simply one that acts on one function, a dyadic operator is one that acts on two functions. The resulting function could be either case by monadic or dyadic; we'll know when it is used. In cases where the same name could denote either a monadic or a dyadic function, the dyadic function takes precedence.</p>
<p>Lua⋆APL goes even further: it accepts functions created by operators as arguments to another operator. In such cases, parentheses must be used.</p>
<p>It is occasionally useful to have a monadic operator whose argument is given in APL as the right argument. In such cases the jot <code>∘</code> is used as dummy left argument. Lua⋆APL syntax demands that <code>∘</code> be the APL name of a function, so the non-standard function <code>Pass</code> has been invented for the purpose. It takes one or two arguments and returns nothing. Its other applications include suppressing printout in the standalone APL executable and creating deliberate runtime errors.</p>
<h2 id="namespaces">Namespaces</h2>
<p>Functions compiled by the APL have <code>_ENV</code> set to the to the APL runtime environment. This environment is not visible to the Lua user.</p>
<p>You have three main mechanisms for getting values back from compiled APL code.</p>
<ul>
<li>Return values of APL statements.</li>
<li>Global assignment.</li>
<li>Printing to the console (see <a href="#functions-added-at-compiler-level">Functions added at compiler level</a>).</li>
</ul>
<p>Three namespaces are visible from an APL function.</p>
<ul>
<li><p>The local namespace of a function. This contains only the names <code>_a</code> and <code>_w</code>, which start out as the values of the left and right arguments, but can be assigned to. They are referred to in the APL code as <code>⍺</code> and <code>⍵</code> respectively.</p></li>
<li><p>The APL global namespace. This contains the functions currently known to APL under their Lua names. The underscore, though alphabetic in Lua, has a special meaning during APL assigment and is therefore best avoided. The APL namespace is a field <code>_V</code> in the APL runtime environment.</p></li>
<li><p>The Lua global namespace, which is set as the <code>__index</code> field of the metatable of <code>_V</code>. The APL global namespace takes precedence when retrieving a value, but if it does not contain that name, the Lua namespace is tried next. Assignment into the Lua namespace from APL is achieved by putting an underscore in front of the name. That underscore is not part of the real name; it merely indicates which namesapce to use.</p></li>
</ul>
<p>Four more namespaces are used by the APL compiler. These are collectively referred to as the APL registry, and contain the same functions as the APL runtime environment, but under their APL names. They contain functions and operators, both monadic and dyadic.</p>
<p>The APL compiler assumes that a name refers to a variable unless it has been added to the APL registry. The easiest way is to assign a newly defined function. The newly defined function will be defined as a monadic function and as a dyadic function (use Lua's runtime distinction if necessary) and can be used wherever a built-in APL function can.</p>
<pre><code>   run=function(str) print(apl(str)()) end
   cf=function(_w,_a) return _w+1/_a end
   run&quot;2 cf 3&quot;
./apl-compiler.lua:113: APL syntax error
2 cf 3
  ↑
   run&quot;cf←cf&quot;    
cf
   run&quot;2 cf 3&quot;
3.5
   run&quot;cf/⌽2 1 2 1 1 4 1 1 6 1 1 8&quot;
2.718281835206</code></pre>
<p>For direct assignment to work, the name must be a valid Lua name too.</p>
<p>More flexibility is offered by the <code>apl.register</code> function. You can define new operators, use a different APL name (which need not be a valid Lua name) from the Lua name), and define help. See <code>help(apl.register)</code>.</p>
<h2 id="functions-added-at-compiler-level">Functions added at compiler level</h2>
<p>The first four functions are standard APL functions, but Lua⋆APL uses them in subtly different ways, so we documemt them fully here.</p>
<dl>
<dt><code>←</code> (<code>Assign</code>)</dt>
<dd><p>Returns its right argument after assigning it to the left argument. This can be used inside expressions, except when the left argument is a parameter (<code>⍺</code> or <code>⍵</code>). In that case, it must occur at the very start of the expression. When used monadically (also only allowed at the start of an expression), returns from the whole APL function.</p>
</dd>
<dt><code>∇</code> (<code>Define</code>)</dt>
<dd><p>This is the only APL function that returns a function as a first-class value. It can take either a string (which is then compiled) or a function (which is simply returned).</p>
<pre><code>   =Deal(100,10)  
Your APL system is now stoned
   print(lua(Define&quot;∇?&quot;))  -- see comment below
return Deal
   Deal=Execute&quot;∇?&quot;        -- recovery!
   =Deal(100,10)
(85,41,79,81,92,24,38,3,34,60)</code></pre>
<p>Note that <code>apl&quot;∇?&quot;</code> does not return <code>Deal</code>, it returns a niladic function whose body is <code>return Deal</code>; that's why we nead <code>Execute</code>.</p>
</dd>
</dl>
<p><code>⍎</code> (<code>Execute) ~   Does</code>Define` and returns the value of the function thus constructed after calling it with no arguments.</p>
<dl>
<dt><code>⎕</code> (<code>Print</code>)</dt>
<dd><p>Returns its argument after printing it. (In some APL's this is a pseudo-variable to which you must assign; in Lua⋆APL it is a monadic function.)</p>
</dd>
<dt><code>lua</code></dt>
<dd><p>Returns the Lua code to which a function has been compiled.</p>
</dd>
<dt><code>register</code></dt>
<dd><p>Registers a Lua function for use by the compiler. See <a href="#extending-luaapl">Extending Lua⋆APL</a>. The interface may change more quickly than this manual. <code>help(register)</code> should give up-to-date instructions.</p>
</dd>
</dl>
<h2 id="apl-functions-not-documented-here">APL functions not documented here</h2>
<p>The Wikipedia article <en.wikipedia.org/APL_Syntax_and_Symbols> does an excellent job, and Lua⋆APL is designed to be downwards compatible with the sections &quot;Monadic Functions&quot;, &quot;Dyadic Functions&quot; and &quot;Operators&quot; from a snapshot of that page made on 12 April 2013.</p>
<p>There are all sorts of little incompatibilities between one APL system and the next, and Lua⋆APL is no exception. These mainly deal with extra features that are not quite standard. An APL reference manual for whatever implementation would nevertheless not be totally useless.</p>
<p>The interactive help is the only documentation that is intended to be kept in sync with the code. You can print out a complete quick reference as follows:</p>
<pre><code>   apl:import()
   for k in help(apl,1):match&quot;:(.*)&quot;:gmatch&quot;%S+&quot; do 
      if k:match&quot;^_&quot; or k==&quot;NaN&quot; then h=help(k,1) 
      else h=help(apl[k],1)         
      end
      if (not h or h:match&quot;^That&#39;s nil&quot;) then 
         print (&quot;No help on&#39;&quot;..k..&quot;&#39;, report this please&quot;)
      else print(h)
      end
   end</code></pre>
<h2 id="complete-syntax-of-luaapl">Complete syntax of Lua⋆APL</h2>
<p>The actual grammar is spcified in LPeg in <code>apl-compiler.c</code> and may by now be a little different from what you read below. It allows neutral whitespace and specifies the Lua code to which a pattern match is translated. Both of these have here been suppressed in the service of legibility.</p>
<p>The capitalized names are terminals which, for the same reason, I prefer to describe in English.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><code>Param</code></td>
<td align="left"></td>
<td align="left"><code>⍺</code> or <code>⍵</code></td>
</tr>
<tr class="even">
<td align="left"><code>String</code></td>
<td align="left"></td>
<td align="left">A Lua string delimited by single-quotes</td>
</tr>
<tr class="odd">
<td align="left"><code>Var</code></td>
<td align="left"></td>
<td align="left">A Lua name or a single UTF-8 character</td>
</tr>
<tr class="even">
<td align="left"><code>Vector</code></td>
<td align="left"></td>
<td align="left">APL-formatted numbers separated by blanks</td>
</tr>
</tbody>
</table>
<p><code>String</code> and <code>Var</code> are subject to exceptions.</p>
<ul>
<li>As currently implemented, a String may not contain a single-quote or a statement separator <code>⋄</code>.</li>
<li><code>Var</code> is any name that has not been listed as a function, an operator, or a parameter. Monadic and dyadic functions and operators have names just like the names allowed for variables, which are only special because they appear in lists kept by the compiler. Those lists are not static. The user can add new items to them at run time (see <a href="#extending-luaapl">Extending Lua⋆APL</a>); once a name has been added to a list, it cannot be removed.</li>
</ul>
<p>Users familiar with BNF should have no difficulty reading this grammar, with the following hints:</p>
<ul>
<li><code>*</code> means that the two elements are adjacent</li>
<li><code>+</code> means that the two elements are alternatives, tried in left-to-right order</li>
</ul>
<p>For example, an expression can consist of just a single variable name (since a variable is a value, and a value is a left argument), but this possibility is only tried when all the other possibilities for an expression have failed.</p>
<pre><code>statement = &#39;←&#39;*expr 
  + Param*&#39;←&#39;*expr 
  + Param*&quot;[&quot;*indices*&quot;]&quot;*&#39;←&#39;*expr
  + expr;
expr = &#39;∇&#39;*func_expr
  + Var*&#39;←&#39;*expr
  + Var*&quot;[&quot;*indices*&quot;]&quot;*&#39;←&#39;*expr 
  + leftarg*dyadic_func*expr 
  + monadic_func*expr
  + leftarg;
dyadic_func = amphiadic_func + Dyadic_function;
monadic_func = amphiadic_func + Monadic_function;
func_expr = &#39;(&#39;*(dyadic_func+Monadic_function)*&#39;)&#39;
  + Dyadic_function + Monadic_function;
amphiadic_func = func_expr*Monadic_operator
   + func_expr*Dyadic_operator*func_expr;
leftarg = value + &#39;(&#39;*expr*&#39;)&#39;;
value = Vector + String +
   Var*&#39;[&#39;*indices*&#39;]&#39; + Var + 
   Param*&#39;[&#39;*indices*&#39;]&#39; + Param;
index = expr+&quot;&quot;;
indices = index*&#39;;&#39;*index + expr;</code></pre>
<h2 id="extending-luaapl">Extending Lua⋆APL</h2>
<p>One can extend APL for particular applications. Here is an example.</p>
<p>In Matlab one finds a very convenient function named <code>diag</code>, which converts between a diagonal matrix and a vector. Let's code a simplified version of it in Lua and teach APL to use the function. There's a very convenient unused UTF-8 character available for the name.</p>
<pre><code>   do
   local rho = apl.util.rho
   local argcheck = apl.util.argcheck
   local shape = apl.util.shape
   local min = math.min 

   local function diag(A)
      local m,n = shape(A)
      if not m then return A end
      if n then 
         n=min(m,n)
         res=rho(0,n)
         for k=1,m do res[k]=A[{k,k}] end
         return res
      end
      res=rho(0,m,m)
      for k=1,m do res[{k,k}]=A[k] end
      return res
   end

   apl.register(1,diag,&#39;⍂&#39;,&#39;Diag&#39;)
   end -- do

   print(apl&quot;⍂1 2 3 4 5&quot;())
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5
   print(apl&quot;⍂(⍳6)∘.×⍳6&quot;())
1 4 9 16 25 36</code></pre>
<p>Notes:</p>
<ol style="list-style-type: decimal">
<li>The functions in <code>apl.util</code> are documented in the Programmer's Guide.</li>
</ol>
<h1 id="apl-mode">APL mode</h1>
<p>The APL standalone interpreter gives an approximation to APL's look-and-feel. Here is a sample session.</p>
<pre><code>$ lua-apl 
Lua 5.2.2  Copyright (C) 1994-2013 Lua.org, PUC-Rio
Lua⋆APL 0.3.0 © Dirk Laurie 2013
apl-lib 0.3.0 © Dirk Laurie 2013
Bug reports are welcome. You&#39;ll find me on Lua-L.
If you can&#39;t remember the README, do this:
  apl:import(); help&#39;start&#39;
--
   apl:import()
   help&#39;APL&#39;
Contents: ! + , . / &lt; = &gt; ? \ ¨ × ÷ ↑ ↓ ∇ ∊ − ∘ ∣ ∧
    ∨ ∼ ≠ ≡ ≤ ≥ ⊂ ⊃ ⊖ ⊤ ⊥ ⋆ ⌈ ⌊ ⌹ ⌽ ⌿ ⍀ ⍉ ⍋ ⍎ ⍒ ⍕ ⍟ ⍪ ⍱ ⍲ ⍳ ⍴ ⎕ ○
   help&#39;⌽&#39;
Reverse(⍵): ⌽⍵ → elements of ⍵ in reverse order
Reverse(⍵,1): ⊖⍵ → rows of ⍵ in reverse order
Reverse(⍵,2): ⌽⍵ → columns of ⍵ in reverse order
Rotate(⍵,⍺): ⍺⌽⍵ → elements of ⍵ rotated left by ⍺ or right by -⍺
Rotate(⍵,⍺,1): ⍺⊖⍵ → elements in columns of ⍵ rotated up by ⍺ or down by -⍺
Rotate(⍵,⍺,2): ⍺⌽⍵ → elements in rows of ⍵ rotated left by ⍺ or right by -⍺
   ⍺←⍳5 ⋄ ←A←⍺∘.×⍺
 1  2  3  4  5
 2  4  6  8 10
 3  6  9 12 15
 4  8 12 16 20
 5 10 15 20 25
   5 ¯5↑A[2 3;3 2]
0 0 0 6 4
0 0 0 9 6
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
   1 3 2 4 5⌽A
 2  3  4  5  1
 8 10  2  4  6
 9 12 15  3  6
20  4  8 12 16
 5 10 15 20 25</code></pre>
<p>This is pretty standard APL, but some points deserve mention:</p>
<ul>
<li>The diamond separator <code>⋄</code> is supported. It is necessary in this case because <code>⍺∘.×(⍺←⍳5)</code> is invalid in Lua⋆APL.</li>
<li>The parameter names (<code>⍺</code> and <code>⍵</code>) are available for temporary values. Other assignments go into the APL global namespace, or even the Lua global namespace (see <a href="#namespaces">Namespaces</a>).</li>
<li>Every input line translates to a single APL function. If that line contains a separator, you must explicitly put in a unary assignment <code>←</code> if you want the function to return something. If there is no separator, the value of the sole APL expression is returned.</li>
<li>The jot (<code>∘</code>) is mapped to the Lua function <code>Pass</code>, which throws away all its arguments and returns nothing. This can be used to suppress printout of one-expression inputs. Implementing jot as a function also removes the need for the compiler to have a separate syntax for the outer product.</li>
</ul>
<p>Some other important points have not been illustrated in the short sample.</p>
<ul>
<li><p>The APL-enabled Lua interpreter pre-empts all the command-line parameters of the standard Lua interpreter. You cannot redirect to its input, and script files cannot be processed. For that, you must use the compiler explicitly from Lua.</p></li>
<li><p>Heuristics are used to guess whether an input chunk is APL. These change so often that I don't document them outside <code>lua-apl.c</code> any more. Ideally, it should not bother anybody: it is very hard to invent a character string that could parse to either correct APL or correct Lua, so it ought to be very easy to see at a glance, even a computer's glance, which it is.</p>
<p>The comments in <code>lua-apl.c</code> (search for &quot;guess&quot;) include tips on how to override a wrong guess.</p></li>
<li><p>If you replay input history (assuming your Lua has that feature) you will notice that your input has been changed to what you would have typed in Lua mode, e.g. <code>2 3⌽A</code> turns into <code>return apl&quot;2 3⌽A&quot;()</code>.</p></li>
</ul>
<h2 id="comparison-with-apl2">Comparison with APL2</h2>
<p>Though not an official standard, IBM's APL2 was a landmark and is well documented (google for <code>APL2LanguageRef.pdf</code>). Lua⋆APL is not and will not be an implementation of the same APL dialect as APL2, but in cases where Lua⋆APL extends older APL usage in the same way as APL2 does, I have tried to use the same symbol for the extension.</p>
<p>Differences of which I am aware between features provided by APL2 and Lua⋆APL are listed below. Unless marked &quot;TODO&quot;, there are no plans to resolve those differences. I would like, though, to be told of any differences not listed or implied below.</p>
<h3 id="downward-incompatibilities">Downward incompatibilities</h3>
<ol style="list-style-type: decimal">
<li>Complex numbers are not supported. Implications include that monadic <code>+</code> means <code>Copy</code>, not <code>Conjugate</code>, monadic <code>×</code> means <code>Sign</code>, not <code>Direction</code>, etc.</li>
<li>Arrays of rank higher than 2 are not supported. Implications include that is no dyadic <code>⍉</code>, etc, and that separate functions and operators are provided for working along the first axis.</li>
<li>Nested arrays are provided via Lua tables, respecting Lua's natural row-wise order. Implications include that monadic <code>⊂</code> or <code>⊃</code> respectively enclose or disclose rows (and if ever extended, will do one rank at a time), and there is no dyadic <code>⊂</code> or <code>⊃</code>, etc.</li>
<li>System variables have different names and do different things.</li>
<li>Index origin 1, not selectable.</li>
<li><code>≠</code>, <code>&lt;</code>, <code>&gt;</code> do not depend on comparison tolerance.</li>
<li>ASCII names for functions are often different even when the function is essentially the same, as motivated above under [Library Mode].</li>
<li>Monadic <code>≡</code> is Lua length; dyadic <code>≡</code> is Lua identity.</li>
<li>No <code>⍷</code>, monadic <code>∊</code> or <code>⌷</code>.</li>
<li>TODO: Dyadic <code>~</code>.</li>
<li>TODO: Monadic <code>↑</code>.</li>
<li>TODO: Dyadic <code>⍒</code> and <code>⍋</code> (will work differently, though).</li>
</ol>
<h3 id="upward-incompatibilities">Upward incompatibilities</h3>
<ol style="list-style-type: decimal">
<li>Lua⋆APL is a Lua package. All of Lua is available. The implications are not individually listed; they include that scalars can be any Lua value except a table, Lua functions can be used to index an array, arrays can be modified at the Lua level, some string-valued keys are used, etc.</li>
<li>Lua⋆APL can be extended by Lua functions registered under APL names. This could be used to provided some non-implemented functionality.</li>
<li>Namespaces.</li>
<li><code>∇</code> and <code>⎕</code> are ordinary APL functions.</li>
</ol>
</body>
</html>
