<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="luaapl-programmers-guide">Lua⋆APL Programmer's Guide</h1>
<p>© Dirk Laurie 2013 Lua-style MIT licence</p>
<p>This part of the documentation is aimed at those who wish understand <code>apl.lua</code>.</p>
<h2 id="apl-levels">APL levels</h2>
<p>The program is divided into four main sections:</p>
<ol style="list-style-type: decimal">
<li>Utilities and the compiler</li>
<li>Primitive scalar functions (<code>_APL_LEVEL=0</code>).</li>
<li>Vector functions (<code>_APL_LEVEL=1</code>). Level 0 functions are redefined to operate on arrays, and vector versions of all APL functions are defined.</li>
<li>Matrix functions (<code>_APL_LEVEL=2</code>). Some level 1 functions are redefined to operate on matrices.</li>
</ol>
<p>If <code>_APL_LEVEL</code> is set before requiring the module, nothing above that level is loaded. This may be useful when trying to isolate bugs.</p>
<p>If <code>_APL_LEVEL&gt;2</code>, some internal tables are made available at the Lua level: <code>f1 f2 op1 op2 rank0 rank1</code>. The first four of these contain the functions used by APL, indexed by their Lua names. The other two contain similar collections, but give the functions as they were at Level 0 and Level 1, before being redefined.</p>
<h2 id="registry">Registry</h2>
<p>APL syntax depends on knowing whether a name refers to a function, a monadic operator, a dyadic operator or a value. For the built-in functions, including functions assigned to APL names, this information is predefined, but for user-defined functions, the function or operator must be registered. The name will then shadow an object of the same name in the APL global namespace.</p>
<p>An unregistered name in an APL expression is always assumed to refer to a value.</p>
<p>The registry appears in the source in the general vicinity of the function <code>register</code> as a table <code>classes</code>. Each of the five entries is an APL-to-Lua dictionary mapping an APL name to a Lua name. The composite dictionary <code>apl_dict</code> gives all the Lua names to which an APL name could be mapped and is used only by the help facility.</p>
<h3 id="rank-modifiers">Rank modifiers</h3>
<hr />
<h1 id="the-core-c-routines">The core C routines</h1>
<p>Some of these have been adapted from other packages: for the block functions I acknowledge useful ideas of John Hind, Steve Fisher and Eike Decker. They are delivered in a table returned by <code>require apl_core</code>.</p>
<p>The table also returns six functions needed for the <code>Circ</code> function (APL <code>○</code>) which are not described here.</p>
<h2 id="block-functions">Block functions</h2>
<p>Block functions all have a table and two integers as their first three arguments. The notation <code>tbl[a:b]</code> is used for a block of values with increasing keys if <code>a&lt;b</code> and decreasing keys if <code>a&gt;b</code>. Thus <code>tbl[b:a]</code> is the reverse of <code>tbl[a:b]</code>.</p>
<hr />
<h3 id="gettblab"><code>get(tbl,a,b)</code></h3>
<p>Returns <code>tbl[a:b]</code>. This function may cause stack overflow if too many items are requested.</p>
<hr />
<h3 id="movetblabcd"><code>move(tbl,a,b,c[,d])</code></h3>
<p>Moves <code>tbl[a,b]</code> to <code>tbl[c,d]</code>, overwriting whatever was there. If <code>d</code> is omitted, it is calculated so that <code>b-a=d-c</code>. Returns <code>tbl</code>.</p>
<hr />
<h3 id="picktblabfctcount"><code>pick(tbl,a,b,fct[,count])</code></h3>
<p>If <code>count==1</code>, returns the first index <code>i</code> in <code>a:b</code> such that <code>fct(tbl[i])</code> is true. If <code>count&gt;1</code>, ignores the first <code>count-1</code> hits. If <code>fct</code> is not a function or if <code>count&lt;1,</code> returns nil.</p>
<hr />
<h3 id="settblab..."><code>set(tbl,a,b,...)</code></h3>
<p>Sets <code>tbl[a:b]</code> to the given values, overwriting existing values.</p>
<p>If the vararg list is empty (not even containing <code>nil</code>), stores nothing. The list is treated cyclically: if it is exhausted before <code>b</code> is reached, the supply of values is resumed from its beginning. If <code>b</code> is nil, values are stored in <code>tbl[a],tbl[a+1],...</code> until the list is exhausted. Returns <code>tbl</code>.</p>
<hr />
<h3 id="transposetblabtarget"><code>transpose(tbl,a,b,target)</code></h3>
<p>Stores the transpose of <code>tbl[1:a*b]</code> in <code>target[1:a*b]</code>. <code>tbl</code> is assumed to contain <code>a</code> blocks of <code>b</code> elements, and <code>target</code> will contain <code>b</code> blocks of <code>a</code> elements. Returns <code>target</code>.</p>
<p><code>tbl</code> and <code>target</code> are not allowed to be the same array.</p>
<hr />
<h3 id="sorttblabcmp"><code>sort(tbl,a,b[,cmp])</code></h3>
<p>Sorts <code>tbl[a:b]</code> by insertion.</p>
<hr />
<h3 id="mergetbllowmiddlehighcmp"><code>merge(tbl,low,middle,high[,cmp])</code></h3>
<p>Merges <code>tbl[low:middle]</code> with <code>tbl[middle+1:high'</code> according to <code>cmp</code> (specified as for the standard <code>table.sort</code>). Both halves are assumed to be already sorted.</p>
<h2 id="apl-functions">APL functions</h2>
<p>These functions operate on or return tables that conform to the specifications for APL arrays. See main documentation.</p>
<h3 id="compatab"><code>compat(a,b)</code></h3>
<p>Tests whether <code>a</code> and <code>b</code> are compatible for term-by-term dyadic functions. That means one of the following conditions holds:</p>
<ol style="list-style-type: decimal">
<li><code>a</code> or <code>b</code> is a scalar or a one-element array.</li>
<li><code>a</code> and <code>b</code> have the same shape.</li>
<li><code>a</code> or <code>b</code> is a vector, and the other is a one-row or a one-column matrix of the same length.</li>
</ol>
<dl>
<dt><code>each(f,x)</code></dt>
<dd><p>Applies unary <code>f</code> term-by-term to every element of <code>x</code>, producing a result of the same shape as <code>x</code>.</p>
</dd>
<dt><code>both(f,x1,x2,e1,e2)</code></dt>
<dd><p>Applies binary <code>f</code> term-by-term to every pair of corresponding elements of <code>x1</code> and <code>x2</code>, whose sizes must be compatible as specified by <code>e1</code> and <code>e2</code>.</p>
<dl>
<dt><code>e1=0; e2=0</code></dt>
<dd><code>x1</code> and <code>x2</code> must have the same shape, which is also the shape of the result.
</dd>
<dt><code>e1=1</code></dt>
<dd><code>x1</code> may be a singleton, treated as equivalent to a constant array of the same shape as <code>x2</code>.
</dd>
<dt><code>e2=1</code></dt>
<dd><code>x2</code> may be a singleton, treared as equivalent to a constant array of the same shape as <code>x1</code>.
</dd>
<dt><code>e1=2</code></dt>
<dd><code>x1</code> is treated as a constant first argument even if it is an array.
</dd>
<dt><code>e2=2</code></dt>
<dd><code>x2</code> is treated as a constant second argument even if it is an array.
</dd>
</dl>
</dd>
</dl>
<h3 id="iotanstart1"><code>iota(n[,start=1])</code></h3>
<p>Returns an APL vector containing the first <code>n</code> integers from the given start.</p>
<h3 id="rhovmn"><code>rho(v,m[,n])</code></h3>
<p>Returns an APL vector of length <code>m</code>, or an APL matrix of shape <code>m×n</code>, filled with copies of <code>v</code>.</p>
<h2 id="other-functions">Other functions</h2>
<h3 id="keepcount..."><code>keep(count,...)</code></h3>
<p>Returns <code>count</code> arguments, starting at the first extra argument. As in the case of <code>select</code>, a negative number indexes from the end (-1 is the last argument).</p>
<hr />
<h3 id="mapft..."><code>map(ft,...)</code></h3>
<p>Each return value is the result of <code>ft</code> applied to the corresponding value in the tuple.</p>
<p>&quot;Applying&quot; means indexing if <code>ft</code> is a table and calling if <code>ft</code> is a function, which is assumed to be unary with one return value.</p>
<hr />
<h3 id="wherelevel"><code>where(level)</code></h3>
<p>Returns a string identifying the point in the source code from which <code>where</code> is being called if <code>level=1</code>, the point from which that routine was called if <code>level=2</code>, etc.</p>
</body>
</html>
