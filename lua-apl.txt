Lua⋆APL User's Manual
=====================

© Dirk Laurie 2013  Lua-style MIT licence

What it says in the README about installation and UTF-8 is not 
repeated here.

There are two modes of usage. 

  - Lua mode: offers APL functionality as a Lua library, which makes
    no use of the APL character set except in its help information,
    and can be used from the standard Lua standalone interpreter.

  - APL mode: replaces the Lua standalone with one that gives an 
    APL-like look-and-feel, with APL notation and an APL-to-Lua
    compiler.

The relationship between the modes can be thought of as analogous to
that between the Lua scripting language and its C API: Lua⋆APL is an
array processing language implemented as a library with a Lua API.

The code examples shown here use the three-space prompt of the Lua⋆APL
standalone rather than the conventional Lua prompt, but all code shown
in the section on [The Lua⋆APL library] works on a vanilla Lua interpreter
too.

In this document, we do not consistently use "APL" and "Lua⋆APL" as
denoting different things. "APL" is a fairly vague term, meaning
more or less "a typical APL implementation" or even "the APL way of
thinking", whereas "Lua⋆APL" is a specific term for this implementation,
which of course also falls under the vague APL umbrella.

Words like `standard` refer to features that are typically found in
almost every APL dialect since about 1980. `Non-standard` in the case
of Lua⋆APL means that I am using an unusual APL symbol without making 
any attempt even to find out how other APL implementations use it.
Please contact me if you feel that some other symbol for the same 
concept is actually semi-standard by now.

When I wrote this, the version number displayed by the start-up message
was `0.2.0`. As long as the first number is `0`, anything might still 
change.

The Lua⋆APL library
===================

The `apl-lib` module offers APL functionality under Lua names. Its
contents is delivered in a table, which I shall assume has been assigned
to the name `apl`. It is best learnt in an interactive session.

A thorough knowledge of what the library offers is not needed if you 
already know APL and plan to use mostly APL mode. If you already know
APL, by all means skip straight to [APL mode] and only read this part
later.

The module returns a table with keys named by the following convention:

-  `CamelCase`: APL functions
-  `lowercase`: Lua utilities
-  `_CAPS`:     needed by the system or providing information

"APL functions" of course does not mean that they are not Lua functions.
It merely means that they are functions that lie at the heart of APL —
almost all of APL consists of predefined functions. There is a one-to-one 
mapping between Lua notation and APL notation, for example:

   Lua                   APL
 ------------------- -- -----------------
   `f(_w,_a)`             `⍺ f ⍵`
   `Range(_w)`            `⍳⍵`
   `Find(_w,_⍺)`          `⍺⍳⍵`
   `Shape(_w)`            `⍴⍵`
   `Reshape(_w,_a)`       `⍺⍴⍵`
   `Decode(_w,_a)`        `⍺⊤⍵`
   `Add(_w,_a)`           `⍺+⍵`
   `Sub(_w,_a)`           `⍺-⍵`
   `Mul(_w,_a)`           `⍺×⍵`
   `Div(_w,_a)`           `⍺÷⍵`
 ------------------- -- -----------------

In total, over 70 of these functions are provided in Lua mode. The APL
symbols used for them, even those which in Lua denote arithmetic 
operators, must be thought of as names, not as as special characters. 

One and the same APL name often does duty for two Lua names. This 
is possible because APL infix syntax can distinguish at compile time
between monadic and dyadic functions (see [Adity]). That distinction 
is possible in Lua too, but only at run time, when one can test 
whether the second argument of a function is present and not nil.

Since APL syntax makes the distinction at compile time, overloading of
the Lua names of the functions is not necessary. Instead, the names 
can be descriptive of what the functions do, instead of naming the
APL symbols (which a pure Lua mode user does not even need to know).

Some semi-standard descriptive names are often used in APL documentation, 
such as <http://en.wikipedia.org/wiki/APL_syntax_and_symbols>. These have
been retained in some cases (`Ravel`, `Reshape` etc), abbreviated in
others (`Mul` rather than `Multiply` etc), and occasionally replaced 
by totally different names (`Range` rather than `Index_Generator`).
There's no rule except what feels programmer-friendly to me.
  
The documentation, in particular the interactive help, freely uses both 
the Lua names and APL symbols simultaneously, so you will acquire 
a smattering of APL more or less painlessly even if you use Lua mode only.

APL types and Lua types
-----------------------
 
An APL-like type structure consisting of functions, operators, scalars,
vectors and matrices is implemented via Lua values. 

The APL terms "function" and "operator" are used in a different sense 
than in Lua. The symbols for arithmetic, comparison etc are called 
operators in Lua and the parser treats them by strict precedence rules. 
In APL, those same symbols are names of functions, there is no 
notion of precedence, and an operator is a function that acts on
functions.

-   APL functions are Lua functions of two variables, returning one
    return value. In the documentation, the names `⍺,⍵` and `_a,_w` 
    are used respectively when the function is called from APL or from
    Lua.  The _left_ argument `⍺` in APL infix notation becomes the 
    _second_ argument `_a` in Lua postfix notation. In APL, the parser
    knows whether `⍺` is omitted; in Lua, providing `_a` as nil is 
    equivalent to omitting it.

-   APL operators are also Lua functions of two variables, but:

    1.  Their arguments and return value are functions.
    
    2.  In the documentation, the first argument is called `f` and 
        the second `g` in the  documentation of both APL and Lua.

    3.  The _left_ argument `f` in APL infix notation becomes the 
        _first_ argument `f` in Lua postfix notation and must always
        be present; the (right) second argument `g` is usually absent, 
        `Inner` being the only function in `apl-lib` that uses it.
     
    4. Operators have a higher priority than functions.

-   APL arrays (vectors and matrices both) are Lua index-1 tables. The 
    ordering of matrix elements is row-wise. More on this in a while.

-   APL scalars are Lua numbers and strings. Other Lua types are 
    treated as scalar. In particular, a Lua function is an APL scalar. 
    This point, too, will be elaborated on.

APL arrays share a common metatable. Numeric keys in the simplest case
obey the same conventions as the Lua table library: the positive integer 
keys of `A` are expected to form a solid block from 1 to `#A`. The full
truth is more complicated; see [Array operations] and [Indexing].

String keys are used to achieve the extra functionality of APL arrays:

    `A.apl_len`: Optional field. If present, this is the value returned 
       by the Lua `#` operator.
    `A.rows`: Number of rows (matrix only).
    `A.cols`: Number of columns (matrix only).

It is possible but never necessary (and definitely not recommended) to 
synthesize an APL array in vanilla Lua. In almost all cases, the APL 
library will accept a Lua "proper sequence" as a substitute for an APL 
vector, and all tables returned by the library are APL arrays. 

For example, to define a matrix (see [Formatting] for `_format`):

       apl._format = 'raw'          
       A = Reshape({11,12,13,21,22,23},{2,3})   
       print(A)
    [11,12,13;21,22,23]
       print(Ravel(A))
    (11,12,13,21,22,23) 

The _rank_ of an array is the number of indices it takes to reference
an element from it. APL allows rank 0 (scalar), rank 1 (vector) and 
rank (matrix). APL does not distinguish between row vectors and column
vectors; if you need to do that, use a one-row or one-column matrix.

`Shape` is the APL analogue of Lua's `type`, defined as follows:

-   number: `Shape(a) = {}`
-   vector: `Shape(x) = {#x}`
-   matrix: `Shape(A) = {A.rows,A.cols}`
-   string: `Shape(s) = #s`
-   other scalar: `Shape(other) = nil` 

It should be stressed that APL matrices are not tables of tables, 
they are simple tables that carry shape information.

Formatting
----------

APL normally uses a pretty-printing output format.

       print(Reshape({11,12,13,21,22,23},{2,3}))
    11 12 13
    21 22 23
       
While nice-looking, this format makes it hard to notice the subtle
distinctions that we will need to make in this manual, and therefore
we have in all the examples used raw format. The Lua⋆APL `Format`
function in general takes two arguments. If the second argument is
absent, the `_format` field in the module table is interrogated. 
Since this table is not read-only, the user can assign something
to `apl._format`. The value `"raw"` selects one-line output with the 
following conventions:

- undelimited: scalars
- delimited by braces: {Lua,table}
- delimited by parentheses: (APL,vector)
- delimited by brackets: [APL,matrix;semicolons,separate,rows]

Not-a-number is printed as `NaN` and nil as an underscore.

       print(Format{1,nil,0/0,"abc"})
    {1,_,NaN,'abc'}

The `Format` function works recursively until something is found that
terminates in a string.

Array operations
----------------

The whole point of using APL is so that one never (well, hardly ever)
needs to use an explicit table index. The vast majority of its functions
accept array arguments and return array values, and in cases where one
argument is a singleton (i.e. a scalar or one-element array) it will
usually be treated as applying term-by-term to the other argument.

Extra control is available by the `Each` and `Both` operators,
see [Nested arrays].

The APL library handles nil arguments gracefully in the case of all 
scalar functions (i.e. functions that apply term-by-term to array
arguments).

       x=Clone{1,2,nil,4}; y=Rev(x)
       print(Add(x,y))
   {5,_,_,5}

Although the actual storage of a very sparse vector will be compact,
using mostly the hash part of an array, there is no true optimized
support for sparse vectors. The functions simply iterate over the
known length of the array and skip nils.

Indexing
--------

APL arrays have a fixed size, which is frozen when the APL metatable
is set. The `__index` and `__newindex` metamethods come into play 
whenever an attempt is made to access any index except those which 
were in use at that moment. Note that those metamethods are _not_
invoked in the case of a valid numeric index; in particular, a matrix
can be accessed via a single valid numeric index.

- A string index works as usual.
- An nonexistent numeric index is illegal.
- If you assign nil to an existing numeric index, that index thenceforth
  becomes unavailable permanently.
- A table-valued index to a vector should either be an APL vector (Lua
  list accaptable) or an APL matrix. The result will have the same shape
  as the index.
- A table-valued index to a matrix should be a pair of items, each of
  which may be a number or a Lua list (APL vectors and matrices are 
  acceptable, but lose their magic powers) which select the rows and 
  columns. The result will have rank determined by the index types and
  shape determined by the lengths of the lists.
- A function-valued index to an array should be an iterator that
  returns a valid numeric index until it returns nil. The result is
  always a vector.

Nested arrays
-------------

The elements of an APL array may be themselves be arrays, since the 
inner structure of an element is opaque to APL, i.e. APL thinks of 
anything stored in an array as scalar. 

       A={{1,2},{3,4},{5,6}}; print(Format(A))
    {{1,2},{3,4},{5,6}}
       B=Clone(A); print(B)         
    ({1,2},{3,4},{5,6})            
       print(A[1]==B[1])
    true

That `true` says that `A[1]` and `B[1]` are actually one and the same 
element, and you can see it: the elements are still the original Lua
tables. This is not quite what is usually wanted from a routine called
`Clone`. The operator `Each` applies a function term-by-term to every
element of a table and returns a new array with the same shape as the
original.

       C=Each(Clone)(A); print(C)
    ((1,2),(3,4),(5,6))

The elements are now newly minted APL arrays, as is the containing
array.

There is also `Both`, which does the same for dyadic functions that
`Each` does for monadic.

       print(Both(Reshape)({{1,2,3,4},{5,6,7,8}},{{2,2}}))
    ([1,2;3,4],[5,6;7,8])

In this example, the two arguments are both nested arrays, so they
looks to APL like a two-element and a one-element array. A function
created by `Both` expects two arrays of compatible shape for 
term-by-term operations, but will accept a one-element second argument
to act as a constant value.  

A vector of vectors of the same length can be combined into a matrix,
and a matrix can be converted to a nested array. These operations are
so commonly needed that the non-standard APL functions `Squish` and 
`Unsquish` have been invented for them.

Strings
-------

Lua⋆APL does not have character arrays, any more than Lua itself has
them. A string is a scalar. If you need to operate on individual bytes
of a string, the Lua function `string.byte` combines well with the 
library.

       tobytes = function(s) return {s:byte(1,-1)} end
       frombytes = function(s) return string.char(unpack(s)) end
       M=Each(tobytes){"The","quick","brown","fox"}; print(M)
    ({84,104,101},{113,117,105,99,107},{98,114,111,119,110},{102,111,120})
       print(Each(frombytes)(M))
    ('The','quick','brown','fox')

List of Lua⋆APL functions
-------------------------

The current version may give a slightly different result, so do it
yourself. For most of these, you can get interactive help.

       help(apl)
    Contents: Abs Add And Attach Attach1 Binom Both Ceil Circ Clone Compress
        Compress1 Deal Decode Div Down Drop Each Encode Exp Expand Expand1 Fact
        Find Floor Format Has Index Inner Ln Log Max Min Mod Mul NaN Nand Neg
        Nor Not Or Outer Pass Pi Pow Range Ravel Recip Reduce Reduce1 Reshape
        Reverse Reverse1 Roll Rotate Rotate1 Same Scan Scan1 Shape Sign Squish
        Sub Take TestEq TestGE TestGT TestLE TestLT TestNE Transpose Unsquish Up
        _F _format help import
       help(Transpose)
    Transpose: ⍉⍵ → matrix transpose of ⍵

`apl._F` contains sub-lists of functions. In some cases, the function is
not the same function as the function of the same name in `apl`, for 
example, `apl._F.Abs` operates only on scalars, but `apl.Abs` operates
on APL arrays.

The APL compiler
================

The compiler is supplied as a separate module `apl-compiler`. This
module loads `apl-lib` and adds some additional items (`Define`,
`Execute`, `Assign`, `register`, `lua` at the time of writing) 
to the module table.  It makes extensive use of APL characters 
in character strings, which are translated to Lua code by the 
compiler. It is possible to use the compiler by itself without 
actually going into APL mode.

I'm assuming you loaded the module by 

       apl=require"apl-compiler"
       apl()

That call to `apl` puts `Define`, `Execute`, `help` and `lua` in the
global environment.

The compiler works as follows:

1.  APL source is split into independent chunks by the `⋄` (diamond)
    separator, each of which is compiled on its own. This implies that
    you are not allowed to use the diamond inside an APL string. You are
    also not allowed to use the single-quote inside. If you really need
    those two characters inside a string, create it using Lua and refer
    to it inside APL by its global name.

2.  An APL chunk is lexed, parsed and translated to Lua code in one step
    by a single LPeg grammar. I thank Roberto Ierusalimschy from the
    bottom of my heart for this absolutely ideal tool.

3.  The result of the previous step is a chunk of Lua code, which looks
    exactly like what you would code in Lua mode, and a number
    identifying the position in the APL code at which the compiler could
    not continue. If that is before the end of the string, the
    compilation failed, and the APL code is displayed with an arrow
    pointing to that position and an error message. This is maybe only
    slightly more helpful than saying there is an error somewhere, but
    at least it gives a starting point.

4.  If the compilation of all the APL chunks succeeded, the Lua chunks
    produced by the compiler are concatenated; if there was only one
    chunk, `return` is put in front of it; the result is tacked onto a
    standard preamble and the whole lot is processed by `load`, with the
    APL runtime environment as fourth argument.

5.  If `load` succeeds (which it should, otherwise there is a compiler
    bug that should be reported), the original APL code is set as the
    help string for the Lua function, which is returned. The Lua code
    can be recovered by `apl.lua`.

All this is done by `apl.Define`, which returns an anonymous function.
`apl.Execute` does all this too, but calls the function immediately and
returns the output.

       sorted_down=Define"⍵[⍒⍵]"
       print(lua(sorted_down))
    return _w[Down(_w)]
       x=Execute"10?100"
       print(x)
    (49,23,96,93,19,89,67,48,66,35)
       print(sorted_down(x))
    (96,93,89,67,66,49,48,35,23,19)

The APL runtime environment has mostly the same keys and values as 
the module table returned by `apl-lib`, but it is a different table. 
You have read-write access to the module table; you have no access 
to the APL runtime environment. There are certain advantages to this.

       =apl.Deal(100,10)
    (85,41,79,81,92,24,38,3,34,60)
       apl.Deal = function() print"Your APL system is now stoned" end
       =apl.Deal(100,10)
    Your APL system is now stoned
       print(Execute"10?100")
    (49,23,96,93,19,89,67,48,66,35)

I'm not saying that a sufficiently sneaky hacker can't access it — 
after all, the module after all is supplied as Lua source code — merely 
that you easily can't clobber it by accident.

Adity
-----

In Lua, the number of arguments to a function is no big deal. You
supply more arguments than the function was defined with? The others
are ignored. You supply fewer arguments than the function was defined 
with? The missing ones are given the value `nil`. This behaviour lies 
at the very heart of the Lua way of thinking,

In APL, the number of arguments to a function is absolutely central.
Funtions are _niladic_ (no arguments), _monadic_ (one argument) or
_dyadic_ (two arguments). Lua⋆APL does not make provision for named 
niladic functions. All functions return exactly one value (which may
be a hugely complicated nested array, though) except the non-standard
function ∘ (`Pass`), which returns nil (and acts as a mere placeholder
to some operators).

The APL syntax allows the adity of a function to be determined by
its context in the expression. Just like Lua knows the difference 
between unary minus and subtraction, APL knows the difference between
monadic and dyadic use of a function symbol — in fact, about 20 APL
symbols can be used for either a monadic or a dyadic function, and
in almost all cases, those functions are implemented by different 
Lua functions.

Operators are even more complicated. In principle there are numerous
possibilities for the adity of an operator, its arguments and its
result. In practice only two kinds occur in standard APL. 

### Monadic operators

A monadic operator acts on a dyadic function to form a monadic function.

### Dyadic operators

A dyadic operator acts on a pair of dyadic functions to form a dyadic 
function. 

The Lua⋆APL library contains a few operators (`Both` acts on a dyadic
function to form a dyadic function, `Each` acts on a monadic function
to form a monadic function) which do not fit into this framework and 
can therefore not be used from APL. Functions created by them can be 
registered for APL use, though.

Namespaces
----------

This is no issue at all in Lua mode: the library functions do not
store or access anything. It is different for functions compiled
by the APL compiler. These have `_ENV` set to the APL runtime 
environment. 

You have three main mechanisms for getting values back from APL.

-  Return values of APL statements.
-  Global assignment (see below).
-  The pseudo-operator `@`. `Define"@f"` does not pass anything to the
   APL compiler, but returns the item with that name from the APL
   runtime environment.

       =Deal(100,10)        -- having forgotten that ...
    Your APL system is now stoned
       Deal=Define"@Deal"   -- recovery!
       =Deal(100,10)
    (85,41,79,81,92,24,38,3,34,60)

Three namespaces are visible from an APL function.

-   The local namespace of a function. This contains only the names `_a`
    and `_w`, which start out as the values of the left and right 
    arguments, but can be assigned to. They are referred to in the APL
    code as `⍺` and `⍵` respectively.

-   The APL global namespace. This contains the functions currently
    known to APL under their Lua names. The underscore, though 
    alphabetic in Lua, has a special meaning during APL assigment 
    and is therefore best avoided. The APL namespace is a field `_V` 
    in the APL runtime environment.  

-   The Lua global namespace, which is set as the `__index` field of the
    metatable of `_V`. The APL global namespace takes precedence when
    retrieving a value, but if it does not contain that name, the Lua
    namespace is tried next. Assignment into the Lua namespace from APL
    is achieved by putting an underscore in front of the name.

Four more namespaces are used by the APL compiler. These are
collectively referred to as the APL registry, and contain the same
functions as the APL runtime environment, but under their APL names.
They contain functions and operators, both monadic and dyadic.

The APL compiler assumes that a name refers to a variable unless it
has been added to the APL registry. The easiest way is to assign a
newly defined function. The newly defined function will be defined
as a monadic function and as a dyadic function (use Lua's runtime
distinction if necessary) and can be used wherever a built-in 
APL function can. 

       cf=function(_w,_a) return _w+1/_a end
       =Execute"2 cf 3"
    ./apl-compiler.lua:113: APL syntax error
    2 cf 3
      ↑
       =Execute'cf←cf'    
    f
       =Execute"2 cf 3"
    3.5
       =Execute"cf/⌽2 1 2 1 1 4 1 1 6 1 1 8"
    2.718281835206

For direct assignment to work, the name must be a valid Lua name too.

More flexibility is offered by the `apl.register` function. You can
define new operators, use a different APL name (which need not be
a valid Lua name) from the Lua name), and define help. 
See `help(apl.register)`.

APL mode
========





returns uses APL characters inside help strings only.
  - APL mode 

recognizes APL characters (in fact, all of UTF-8) as
    alphabetic characters for the purpose of forming Lua names and
    offers most of APL under one-codepoint APL names.

applies heuristics to guess whether an input chunk is APL 
    or Lua and treats each appropriately differently with no user 
    intervention. It is intended to be used only from an interactive 
    terminal. Experienced APL users should be able to get very far
    without reading any further than this.


    
The APL-enabled Lua interpreter pre-empts all the command-line
parameters of the standard Lua interpreter. You cannot redirect to its
input, and script files cannot be processed. 

Chunks you type in are guessed to be either APL code or Lua code,
according to the following criteria applied to the first line in the
given order.

1.  If it starts with `return` or '=': Lua.

2.  If it does not start with an alphabetic character or left 
    parenthesis: APL. Note that this stops you from entering comments
    or goto labels at the start of the first line of a Lua chunk.

3.  If it contains the string `apl.` or a double-quote: Lua.

4.  If it contains an APL statement separator `⋄` or comment symbol 
    `⍝`: APL.

5.  If the number of non-ASCII bytes is more than the number of
    alphabetic bytes: APL.

A chunk guessed to be APL is formatted by `return ⍎"%s"` and treated as
in Mode 2. As in the case of the Lua interpreter, the changed line, not
the original, appears when the history of the session is replayed. The
APL Execute symbol `⍎` has been put into the global namespace so that
this trick can work.

To override a wrong guess that something is APL, you could do something 
that will trigger criterium 1 or 3. To override a wrong guess that 
something is Lua, put `⍕` in front if output is required and `∘` if not.
        
UTF-8 mode
----------

This mode is a compromise between APL mode and Lua mode; at the start of
this project, it was the only mode. It is in the process of being split
up between the other two modes. Unless an army of enthusiastic users 
springs up unexpectedly, I plan to remove it as soon as Lua mode is 
fully operational.

Invoke the interpreter by `lua-utf8 -l apl -e "apl()" -i`; inside
a program, do `apl=require"lua-apl"()`. Four functions are put into 
the global namespace.

-   `∇`: load APL code as a function
-   `⍎`: load and execute APL code
-   `lua`: return the Lua code of a function
-   `help`: interactive help

You can then:

a.  Operate as in APL mode, but there is no guessing and no reformatting.
    You need to do `=⍎"APLexpr"` explicitly.
b.  Load a function using `∇`, assign it to a Lua name, and call it from 
    Lua later.
c.  Call APL functions by their one-character UTF-8 names, e.g.

        print(apl.⌽(apl.⍳(10)) --> 10 9 8 7 6 5 4 3 2 1

d.  Use Lua operators on already-constructed APL objects. This is not
    recommended because of the confusion it can generate: the
    expressions follow Lua's rules of precedence; common operators like
    `*` mean different things to APL and Lua, etc. No further
    documentation is provided; you are on your own.
        
Lua mode
--------

WARNING: This section describes plans for the future. What works at any
given moment is to de found by experiment.

Invoke the interpreter by "lua -l apl-lib". You do not have APL notation
available at the Lua code level, but if you are running an APL keyboard
and display, you can create strings containing APL code and load then by
`Define` or load-and-run them by `Execute`. The APL functions are not 
available from Lua by their APL names, but by their ASCII names. Since 
these are long enough by themselves, it may be useful to avoid having 
to prefix them by `apl.`: you can load them into the global namespace 
by `apl.import()`.

    print(Reverse(Range(10))) --> 10 9 8 7 6 5 4 3 2 1

### How does the APL compiler work?

The function `Define`, also called `apl.∇` in the other two 
interpreters, translates APL code to Lua code.

    Define"⌽⍳10" --> Reverse(Range(10)) 

A standard preamble is supplied, and the result processed by Lua's
`load` function, given the Lua⋆APL module table as environment.  The 
effect of `Define"⌽⍳10"` is the same as if you coded:

    function (⍵,⍺)
       local _ENV=apl 
       local function seta(v) ⍺=v return v end 
       local function setw(v) ⍵=v return v end 
       return Reverse(Range(10))
    end

If you use `⍺` and `⍵` inside an APL expression, the result will
depend on the input parameters.  The `seta` and `setw` functions are 
provided so that there is a way to change the values of the local 
variables `⍺` and `⍵` from inside the function.

       =lua(∇"(⍺←⍺+⍵)⋆⍵")
    ⋆(⍵,seta(Add(⍵,⍺)))
    
Things all users must know
==========================

From here onwards, "APL" will mean "the dialect of APL supported by
Lua⋆APL".  This is mostly compatible with APL⋆PLUS (from which the APL 
star in the name has been borrowed), but without the things Lua does 
better: program structure, system calls, input-output etc.


APL types vs Lua types
------------------------

APL recognizes five types: functions, operators, scalars, vectors and 
matrices. These are accommodated in Lua types as follows:

-   APL scalars are Lua numbers or strings.  As in Lua, _strings are 
    not character arrays_, they are string scalars. Most APL functions 
    do not distinguish these in cases where Lua would not, e.g. 
    `'30'×'40'` or `Multiply('30','40')` will happily return the number 
    `1200`. Only a handful of functions expect or produce strings, but 
    several others can handle them.

    Lua userdata, if assigned to global Lua names, are also APL scalars. 
    If equipped with the right metamethods, they might work inside APL 
    expressions, but this possibility is unexplored.
   
-   APL functions are implemented as Lua functions, but the *left* APL
    argument is the *second* Lua argument. Think of the Lua 5.2
    `math.log` function: it is already the correct implementation of the
    APL `⍟` (Logarithm). As in Lua, whether a function is called
    monadically or dyadically is only decided at runtime, but the APL
    functions are truly polymorphic and different Lua functions can be
    called in the two case.

-   APL functions are not first-class values. The `∇` function (Define)
    returns an anonymous Lua function, which can be assigned to a name 
    in either the Lua global namespace or the APL function namespace, 
    but not in the APL namespace `apl._V.` 

    Once a function is in the APL function namespace, it is treated 
    just like any built-in function by the APL compiler. In particular,
    it needs to be called with an argument.

    Functions in the Lua global namespace, on the other hand, are
    visible to APL if not shadowed and regarded by the APL compiler
    as values, not as functions, as by the APL compiler.

    The `@` operator (Address) turns an APL function into an APL value.

           f ← ∇'⍵+10×⍺'
           _g ← f@1   ⍝ _g←f would be a syntax error
           =g(5,7)
        75

    The argument `1` in `f@1` is meaningless, but APL syntax requires
    it.

-   APL operators are implemented as Lua functions.

-   APL vectors are origin-1 Lua tables. There should be no holes, i.e.
    positive integer indices for which `tbl[k]==nil` but `tbl[k+1]~=nil`
    are illegal. Vectors of vectors can be handled by some functions,
    and conversion of a matrix to and a vector of rows is offered by
    the non-standard APL functions `Squish` (`⌷`) and `Unsquish` (`⌻`).

-   APL matrices are origin-1 Lua tables like APL vectors, but have a
    field `shape` which contains a table with two numbers, the number of
    rows and columns.

-   Indexing in APL is dyadic; in Lua it is monadic. Tables and Lua
    functions (not APL functions) are used as indices to APL arrays 
    to achieve equivalent (in fact more versatile) functionality,


Description from the APL point of view
======================================

The functions do what one could expect the corresponding APL functions
to do, except that the values they act on are Lua values: numbers,
strings, tables and functions. They all take one or two arguments, 
traditionally called ⍺ and ⍵, and return one value.

Although an APL reference manual would not be totally useless — the
Lua⋆APL dialect is intended to conform to APL⋆Plus Special Edition with
some features from APL2. There is no attempt to reproduce the exact
behaviour of any current APL implementation; on the contrary, some
symbols also used by more recent APLs are used here to mean something
different. *The definition of the function is what it says in the
interactive help for it.*

The following symbols either are absent from APL⋆PLUS or have extended 
meanings here:

    ⌷ ⌻ @ # ¨ ∘ ∇ ⍴
    
You get help by giving the symbolic name as argument.

       help'+'
    1. Clone: +⍵ returns an exact copy of ⍵
    2. Add = function(⍵,⍺) return ⍺+⍵ end

Names like `Clone` and `Add` are specific to this implementation. You
do not need them in APL mode.

### Assignment

When you assign to name starting with an underscore, the underscore
is removed and the value is assigned to a name in the Lua global
namespace.

           _a←1 2 3 ⋄ _b←4 5 6
           print(a,b)
        1 2 3	4 5 6

The same applies to defined functions. Functions assigned to names 
in the Lua global namespace are regarded as mere values by APL. Only
these functions can be used by themselves as table indices.

### System calls, input and output

There is no support at the APL level. You must use Lua for this.    

### Diagnostics

The APL compiler has rudimentary support for finding syntax errors. It
displays the offending source and indicates the first character such
that the substring up to the previous position is still valid APL code,
but that no further progress is possible. In some cases, e.g.
parenthesized expressions or expressions that contain function
definitions, this may be a long way before the actual error.

Run-time diagnostics are designed to be more informative.

### System variables

Variables whose names start with `⎕` are reserved for system variables,
that is, APL variables on which the behaviour of certain functions may 
depend.

At present, the following system variables are recognized.

⎕format
:   The format to be used by monadic `⍕`. This must be a Lua
    format string with one slot, e.g. `%.14g`.

⎕pp
:   The number of digits appearing after the decimal point in the
    format used by monadic `⍕` when there is no `⎕format`.  This
    will be used to generate an appropriate format for the particular 
    value being formatted.  

Description from the Lua point of view
======================================

The APL functions `⌷` (Squish) and `⌻` (Unsquish) convert to and
from Lua types that have no APL counterpart.  In the following,
lower-case names refer to Lua values of the type under discussion
(they can be seen by APL is assigned to global Lua names), upper 
case names refer to APL names.

We assume that the CamelCase names have been made visible without
need for qualification.

### Nil

APL does not have a concept of `nil`. `Squish(x)` (or `⌷x`) converts 
nils to `NaN`, which has the type `"number"` even though it is 
not-a-number. All arithmetic operations involving `NaN` have result 
`NaN`; all APL comparison operations involving `NaN` have result `0`, 
even `NaN==NaN`. You cannot convert `NaN` back to `nil`. If you need 
APL to return a nil for consumption by Lua, the function `Pass` 
(or `∘`) will do (although strictly speaking it returns nothing, not
nil). 

### Booleans

APL has no Boolean type. APL comparison and logical functions return 
0 or 1, _both of which are `true` to Lua_. `Squish(b)` (or `⌷b`)
converts a Lua table of Booleans to 0-1 values, `Unsquish(B)`
(or `1⌻B`) converts an APL array to Booleans.

### Strings

Lua strings are treated as scalars. APL-style characters and character
matrices are not supported, and the use of string-valued arguments to
any APL function except `⍎` and `⍕` has not really been tested.  The 
coherence of both APL and Lua is so good that useful results may well 
in some cases be obtained from string arguments.

If you really need character vectors, you can converting strings
to vectors of byte values.

       x=Squish"⍺-⍵"
       =x
    226 141 186 45 226 141 181
       =Execute'2⌻x'
    ⍺-⍵

### Tables

Even though holes are illegal, it is very inefficient to test for them
all the time. Like the Lua table library, therefore, APL relies internally 
on the built-in length operator `#` to give the length of arrays. If you 
create all your APL tables via built-in APL functions, including `⌷`, 
this should not be a problem. If an APL function ever returns an array 
with a hole, it is a bug that I would like to be informed of.

All APL functions accept any Lua array, but returned arrays are APL
arrays. The only difference is that APL arrays are provided with a
metatable, which defines a `tostring` function reminiscent of how APL
implementations print arrays, and metamethods for the arithmetic
operations, indexing and concatenation. Arrays passed as arguments to 
APL functions may on return be found to have acquired this metatable,
even though the return value is a different table. It is not considered 
to be a bug when this happens.

APL matrices differ from APL vectors in having a `shape` field. The
presence of this field influences the behaviour of many functions,
most of which however have not been implemented at this stage. The
shape is a two-element vector giving the number of rows and columns
respectively.

### Functions

Any Lua function is a valid APL function too. However, a Lua name
referring to a function will be regarded as a value by the the APL
compiler. This is a feature, not a bug, since an APL index must be
a value.


------------------------------------------------------------------------

Obsolete part of manual; some items may still be true and not covered
above.

General design
--------------

Most of the functions in the module table have one-character names, and 
most of those names are non-ASCII UTF-8 codepoints actually occupying
two or three bytes. The characters are traditional APL characters, 
e.g. `×`, but they are not special characters.  They look like names 
to the patched Lua 5.2, and they need to be separated from other names
just like the usual names.

In some cases, the one-character name is an ASCII character, e.g. `+`.
These have been kept to an absolute minimum, and non-ASCII equivalents
as described under __UTF-8 Essentials__ have been used whenever possible. 
Whenever the function name is a non-alphabetic ASCII character, an alias 
consisting of alphabetic characters has been provided, e.g. `plus`.

For APL functions that you defined yourself, `help` prints the APL code
and `lua` gives the Lua code as a string.

       f=∇"⍵/(1+⍺)"
       help(f)
    ⍵/(1+⍺)
       =lua(f)
    ∇: slash(plus(⍺,1),⍵)


Mapping from Lua to APL is done by the squish function, which converts
a vector of vectors to a matrix with the given rows. This can be
called from Lua or from APL.

       A=apl.⌷{{1,2,3},{4,5,6}}
       =A
    1 2 3
    4 5 6
       =apl.⌷(A.shape)
    2 3
       t={{1,2,3},{4,5,6}}
       ⌷t
    1 2 3
    4 5 6

You can unsquish too:


   
Some APL functions require that numeric values actually be integers
or 0-1 quantities. Their behaviour when given invalid arguments
is undefined: they may in some way still work; there may be a test 
for the required property; there may be a Lua error message; they 
may quietly return nonsense.



## Using the functions directly from Lua

The Lua⋆APL module (loaded say as `apl`) does not place anything in the 
global namespace. You access the functions as `apl.⍴`, `apl.plus`,
`apl['+']` etc. This is intolerable for the very commonly used
`apl.∇` and `apl.⍎`, so `apl` has been made callable to put these
two functions as well as `lua` and `help` into `_ENV`.

If you use any other function often enough, it quickly becomes tiresome
to type "`apl.`" in front of it every time. So for the rest of this
discussion I will assume that the required function has been made
visible in the current namespace, whether as a global, a local or
an upvalue.

Functions with UTF-8 names are easiest.
You write `⋆⍵` in APL to compute the exponential function; you
write `⋆(⍵)` in Lua. If `⍵` is an array, the function is applied 
term-by-term.

       =⋆{1,2,3}
     2.71828  7.38906 20.08554
    
You write `⍺⋆⍵` in APL to compute the power function; you write 
`⋆(⍵,⍺)` in Lua.  You only need `⋆(⍵,⍺)` if neither of `⍺` and 
`⍵` is an APL array, otherwise `a^⍵` will also work.

For the power function, as for most of the standard arithmetic and
comparison functions, `(⍵,⍺)` can be any combination of scalar and 
array. If both terms are arrays, they must be of equal length.

       ⋆({1,2,3},{4,5})
    ./apl.lua:454: array arguments of unequal size
    stack traceback:
    	[C]: in function 'error'
    	./apl.lua:454: in function 'f2'
    	./apl.lua:467: in function '⋆'
    	stdin:1: in main chunk
    	[C]: in ?
       =⋆({1,2,3},{6,5,4})
     6 25 64

APL operators look exactly APL functions from the Lua point of view,
but have different semantics. The arguments to operators are functions, 
and the result is also  a function. Since monadic operators have only
a left operand, the operands to a dyadic operator are (left,right),
not (right,left) as for functions.

~~~
   prod = ⌿(×)
   =prod(⍳(6))
720
   cumprod = ⍀(×)
   =cumprod{1,2,3,4,5,6}
1 2 6 24 120 720
   dotprod = dot(plus,×)
   =dotprod({3,4,5},{1,-2,1})
0
~~~

It is ignored if only integers need to be

## Using the functions via the APL compiler

The `∇` function creates a Lua function from a given string by parsing
it as an expression written in APL, according to the APL syntax rules:

1. The right argument of a function is all of the rest of the 
   expression.
2. The left argument of a function is only the single operand to
   the left of it.
3. Parentheses may be used to override the first two rules.
4. The left argument of an operator is only the single operand,
   to the left of it, which must be a function.
5. The right argument of a dyadic operator is the single operand
   to the right of it.

An APL expression may freely use the ASCII names of functions, even 
when that name is a single special character. The Lua equivalent,
being valid Lua code, will contain either a non-ASCII name or an
alphabetic alias.

The resulting Lua functions may be nil-adic, monadic or dyadic, i.e. 
they take no arguments `()`, one argument `(⍵)` or two arguments 
`(⍵,⍺)`. The specific names `⍺` and `⍵` must be used. When called 
from APL, `⍺` refers to the left argument and `⍵` to the right argument.

You can't return the function generated by an operator as you can 
directly from Lua. I.e. in Lua `f=slash(plus)` is perfectly legal, 
but in an APL expression you must give arguments, i.e. `f=∇"+/⍵"`.

A nil-adic function can be evaluated immediately by using `⍎` instead
of `∇`. The result is a Lua value. An APL function can only return `nil`
if there was an error.

APL expressions may contain user variables.

       x={1,2,3}
       =⍎'+/÷x'
    1.8333333333333

Lua⋆APL searches for these variables first in `apl._V` (or simply
`_V` if you invoked `apl()`). If not found, tries the environment 
(i.e. `_ENV`).

The names recognized inside APL expressions are more restricted than 
those recognized inside Lua. Only the first character may be a 
non-ASCII UTF-8 codepoint, and that codepoint must not be the name 
of an APL function.

For forward compatibility, it is wise not to start a name with any 
of the currently unused symbols on the APL keyboard given above.

In an APL expression, user-defined functions may be used, but they
must already have been defined as functions at compilation time,
whether in `_V` or in `_ENV`.

~~~
   s1=∇'f*g⍵' -- assumes f and g are non-functions
./apl.lua:171: bad input to apl2lua: two adjacent non-functions
f*g⍵
   ↑

   g=load''   -- a dummy function
   s2=∇'f*g⍵' -- assumes g is a function
   =lua(s2)   --> ⋆(g(⍵),f)  
local ⍵,⍺=... return ⋆(g(⍵),f)

   f=load''
   s3=∇'f*g⍵' -- assumes f and g are functions 
   =lua(s3)   --> f(⋆(g(⍵)))
local ⍵,⍺=... return f(⋆(g(⍵)))
~~~

Note that all names used in an APL expression are non-local. That
implies that the function `f` executed when you finally evaluate
`s2` will be whatever value `f` has then.

## Notes on specific functions

Some functions are non-standard.

-   Some versions of APL do not define them.
-   Those that do, do not always do it in the same way.

I hope most of the cases where this dialect of APL is nonstandard
are documented below. Remember that _there are no string literals_.

Ways of calling a function shown before the semicolon apply to Lua;
those shown after, to APL.

`add_function(name,func)`
:   Registers a name with the APL compiler as a function or as an
    operator. `func` is a table in which `func[1]` is the monadic
    function and `func[2]` the dyadic function associated with the
    given name. If only one of the two is given, that one will be
    used for all calles. Several key-value options are available:
    see the online help.

Assign: `; ⍺←⍵`
:   The assign function `←` stores `⍵` in `apl._V` at the key `⍺`. 
    This value takes precedence in an APL expression over a global 
    Lua variable with the same name. 

Define: `f=∇"APL source", f=∇("APL source","APL name"); ⍺∇⍵`
:   This is implemented as an APL function, not a system function.
    The argument is a string, so that the function must either be
    called from Lua or the string argument `⍵` must have been created 
    earlier. The argument `⍺` must be a name not yet known to the
    APL compiler, under which the new function will be registered.

    The result is always a function of two arguments, as described in
    [How does the APL compiler work?].

Format: `; ⍺⍕⍵`
:   The dyadic format function uses a number as format: `12` means 
    `%12d`, `12.6` means `%12.6f` and `¯12.6` means `%12.6e`. You can't
    have more than 9 digits after the decimal point. An array of
    numbers can be given: they apply term-by-term if `⍵` is a
    vector and columnwise if `⍵` is a matrix.

    You can also supply a string-valued format or array of formats.

Pass: `; ∘⍵, ⍺∘⍵`
:   Apart from its role as a placeholder in an outer product, this 
    function ignores its arguments and returns nothing. This bare 
    fact is mentioned without any claim that it is useful.

Squish: `apl.⌷"...", apl.⌷{...}, apl.⌷(⍵); ⌷⍵`
:   Lua-to-APL conversion. 

    - If `⍵` is nil, it is replaced by `NaN`.
    - If `⍵` is boolean, it is replaced by a 0-1 value.
    - If `⍵` is a string, it is converted to an array of byte values.
    - If `⍵` is any other scalar, it is returned unchanged by `⌷⍵`.
      This is unlikely to be useful except in the case of a number.
    - If `⍵` is a table, and none of the entries in `⍵` is itself 
      a table, `⍵` is converted to an APL table by setting its metatable, 
      and returned. No new table is created.
    - Otherwise the entries in `⍵` must all be tables of the same length,
      and an APL matrix of which they are the rows is created.

Unsquish: `; ⍺⌻⍵`
:   APL-to-Lua conversion. A selective inverse of `⌷`.

    - Always: Matrices are converted to vectors of rows. 
    - `⍺=1`: 0 is converted to `false`, other values to `true`.
    - `⍺=2`: Numbers in the range 0 to 255 are converted to bytes.
      Vectors become strings, matrices become arrays of strings.


Scan, Reduce: `⍺/⍵`, `⍺⌿⍵`, `⍺\⍵`, `⍺⍀⍵`
:   When given an empty argument `⍵`, the reduce operators return the 
    unit of the function `⍺` e.g. `⌈/0⍴0` returns `-Inf`, or raise an
    error if no unit is defined. The scan operators always raise an 
    error if no unit is defined. At present only the associative dyadic
    functions `+ − ∨ ∧ ⌈ ⌊` have units, and there is no mechanism to
    define other units.

